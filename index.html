<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Backrooms FPS</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    #joystick {
      position: absolute;
      bottom: 50px;
      left: 50px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      touch-action: none;
    }
    #stick {
      position: absolute;
      left: 40px;
      top: 40px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255,255,255,0.6);
    }
  </style>
</head>
<body>
<div id="joystick"><div id="stick"></div></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();

// --- Lumière type Backrooms ---
const hemiLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
scene.add(hemiLight);

// --- Caméra ---
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 0); // hauteur des yeux

// --- Rendu ---
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Sol + plafond ---
const floorTex = new THREE.TextureLoader().load("https://i.imgur.com/5R3qK2R.jpeg");
floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
floorTex.repeat.set(50, 50);
const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshLambertMaterial({map: floorTex}));
floor.rotation.x = -Math.PI/2;
scene.add(floor);

const ceilTex = new THREE.TextureLoader().load("https://i.imgur.com/MvZfm1M.jpeg");
ceilTex.wrapS = ceilTex.wrapT = THREE.RepeatWrapping;
ceilTex.repeat.set(50, 50);
const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshLambertMaterial({map: ceilTex}));
ceiling.rotation.x = Math.PI/2;
ceiling.position.y = 3;
scene.add(ceiling);

// --- Murs (labyrinthe) ---
const walls = [];
const wallMat = new THREE.MeshLambertMaterial({color: 0xe3e3a3});
const CELL = 5;
for (let x=-50; x<50; x+=CELL) {
  for (let z=-50; z<50; z+=CELL) {
    if (Math.random()>0.8) {
      const wall = new THREE.Mesh(new THREE.BoxGeometry(CELL,3,CELL), wallMat);
      wall.position.set(x,1.5,z);
      scene.add(wall);
      walls.push(wall);
    }
  }
}

// --- Contrôles joystick ---
let moveX = 0, moveZ = 0;
const joy = document.getElementById("joystick");
const stick = document.getElementById("stick");
let joyId = null;

joy.addEventListener("touchstart", e=>{
  if (joyId===null) joyId = e.changedTouches[0].identifier;
});
joy.addEventListener("touchmove", e=>{
  for (const t of e.changedTouches) {
    if (t.identifier===joyId) {
      const rect = joy.getBoundingClientRect();
      const dx = t.clientX-(rect.left+rect.width/2);
      const dy = t.clientY-(rect.top+rect.height/2);
      const dist = Math.min(Math.sqrt(dx*dx+dy*dy), rect.width/2);
      const angle = Math.atan2(dy,dx);
      stick.style.left = rect.width/2+Math.cos(angle)*dist-20+"px";
      stick.style.top = rect.height/2+Math.sin(angle)*dist-20+"px";
      moveX = Math.cos(angle)*dist/(rect.width/2);
      moveZ = Math.sin(angle)*dist/(rect.height/2);
    }
  }
});
joy.addEventListener("touchend", e=>{
  for (const t of e.changedTouches) {
    if (t.identifier===joyId) {
      joyId = null; moveX=0; moveZ=0;
      stick.style.left="40px"; stick.style.top="40px";
    }
  }
});

// --- Contrôles caméra multitouch ---
let lookId = null;
let yaw=0, pitch=0;
let sensitivity=0.003;

document.addEventListener("touchstart", e=>{
  for (const t of e.changedTouches) {
    if (t.target!==joy && joyId!==t.identifier && lookId===null) {
      lookId = t.identifier;
    }
  }
});
document.addEventListener("touchmove", e=>{
  for (const t of e.changedTouches) {
    if (t.identifier===lookId) {
      yaw -= t.movementX || 0;
      pitch -= t.movementY || 0;
    }
  }
});
document.addEventListener("touchend", e=>{
  for (const t of e.changedTouches) {
    if (t.identifier===lookId) lookId=null;
  }
});

// fallback souris pour debug
let prevX, prevY;
document.addEventListener("mousemove", e=>{
  if (e.buttons===1) {
    if (prevX!==undefined) {
      yaw -= (e.clientX-prevX)*sensitivity;
      pitch -= (e.clientY-prevY)*sensitivity;
    }
    prevX=e.clientX; prevY=e.clientY;
  }
});

// --- Animation ---
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const speed = 0.75 * 3; // vitesse réaliste

  // clamp pitch
  pitch = Math.max(-Math.PI/2*0.95, Math.min(Math.PI/2*0.95, pitch));

  // orientation FPS
  const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
  camera.lookAt(camera.position.clone().add(new THREE.Vector3(
    Math.sin(yaw)*Math.cos(pitch),
    Math.sin(pitch),
    Math.cos(yaw)*Math.cos(pitch)
  )));

  // déplacement
  const oldPos = camera.position.clone();
  camera.position.addScaledVector(dir, moveZ * speed * delta);
  camera.position.addScaledVector(right, moveX * speed * delta);

  // collisions murs
  const radius=0.5;
  for (const wall of walls){
    const dx=Math.abs(camera.position.x-wall.position.x);
    const dz=Math.abs(camera.position.z-wall.position.z);
    if (dx<CELL/2+radius && dz<CELL/2+radius){
      camera.position.copy(oldPos);
      break;
    }
  }

  // collisions bords
  const MAP_HALF_SIZE=50, margin=0.5;
  camera.position.x=Math.max(-MAP_HALF_SIZE+margin,Math.min(MAP_HALF_SIZE-margin,camera.position.x));
  camera.position.z=Math.max(-MAP_HALF_SIZE+margin,Math.min(MAP_HALF_SIZE-margin,camera.position.z));

  // hauteur fixe
  camera.position.y=1.6;

  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>













