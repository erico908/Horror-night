<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms FPS</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #joystick {
      position: absolute; bottom: 30px; left: 30px;
      width: 80px; height: 80px; border-radius: 50%;
      background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
      touch-action: none;
    }
    #stick {
      position: absolute; left: 35px; top: 35px;
      width: 30px; height: 30px; border-radius: 50%;
      background: rgba(255,255,255,0.5);
    }
  </style>
</head>
<body>
  <div id="joystick"><div id="stick"></div></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    // ---------- SCENE ----------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0, 1.6, 0);

    // ---------- TEXTURES ----------
    const loader = new THREE.TextureLoader();
    const texFloor = loader.load("https://ambientcg.com/get?file=Carpet006_1K_Color.jpg");
    texFloor.wrapS = texFloor.wrapT = THREE.RepeatWrapping;
    texFloor.repeat.set(20,20);

    const texWall = loader.load("https://ambientcg.com/get?file=Wallpaper001_1K_Color.jpg");
    texWall.wrapS = texWall.wrapT = THREE.RepeatWrapping;
    texWall.repeat.set(10,4);

    const texCeil = loader.load("https://ambientcg.com/get?file=CeilingTile001_1K_Color.jpg");
    texCeil.wrapS = texCeil.wrapT = THREE.RepeatWrapping;
    texCeil.repeat.set(20,20);

    // Sol
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(100,100),
      new THREE.MeshStandardMaterial({map: texFloor})
    );
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // Plafond
    const ceil = new THREE.Mesh(
      new THREE.PlaneGeometry(100,100),
      new THREE.MeshStandardMaterial({map: texCeil})
    );
    ceil.rotation.x = Math.PI/2;
    ceil.position.y = 3;
    scene.add(ceil);

    // ---------- MURS ----------
    const walls = [];
    const CELL = 10;
    for (let x=-50; x<=50; x+=CELL) {
      for (let z=-50; z<=50; z+=CELL) {
        if (Math.random() > 0.75) {
          const wall = new THREE.Mesh(
            new THREE.BoxGeometry(CELL,3,CELL),
            new THREE.MeshStandardMaterial({map: texWall})
          );
          wall.position.set(x,1.5,z);
          scene.add(wall);
          walls.push(wall);
        }
      }
    }

    // ---------- LAMPE TORCHE ----------
    const torch = new THREE.SpotLight(0xffffcc, 2, 15, Math.PI/6, 0.3);
    torch.position.set(0,1.6,0);
    torch.target.position.set(0,1.6,-1);
    scene.add(torch);
    scene.add(torch.target);

    // ---------- SON ----------
    const listener = new THREE.AudioListener();
    camera.add(listener);
    const sound = new THREE.Audio(listener);
    const audioLoader = new THREE.AudioLoader();
    audioLoader.load("https://cdn.pixabay.com/download/audio/2022/02/23/audio_4b64b0fcd2.mp3?filename=neon-light-hum-14213.mp3",
      (buffer)=>{
        sound.setBuffer(buffer);
        sound.setLoop(true);
        sound.setVolume(0.3);
        sound.play();
      });

    // ---------- LUMIERE AMBIANTE ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.1));

    // ---------- JOYSTICK ----------
    let yaw = 0, pitch = 0;
    let moveX = 0, moveZ = 0;
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");
    let joyActive = false, joyCenter = {x:0,y:0};

    joystick.addEventListener("touchstart", e=>{
      joyActive = true;
      const r = joystick.getBoundingClientRect();
      joyCenter = {x: r.left+r.width/2, y:r.top+r.height/2};
    });
    joystick.addEventListener("touchend", ()=>{
      joyActive=false;
      stick.style.left="35px"; stick.style.top="35px";
      moveX=moveZ=0;
    });
    joystick.addEventListener("touchmove", e=>{
      if(!joyActive) return;
      const t=e.touches[0];
      const dx=t.clientX-joyCenter.x, dy=t.clientY-joyCenter.y;
      const dist=Math.min(Math.sqrt(dx*dx+dy*dy),40);
      const ang=Math.atan2(dy,dx);
      stick.style.left=35+dist*Math.cos(ang)-15+"px";
      stick.style.top=35+dist*Math.sin(ang)-15+"px";
      moveX = dx/40;
      moveZ = dy/40;
    });

    // ---------- CAMERA SWIPE ----------
    let lastX=null,lastY=null;
    document.addEventListener("touchstart", e=>{
      if(!e.target.closest("#joystick")) {
        lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
      }
    });
    document.addEventListener("touchmove", e=>{
      if(!e.target.closest("#joystick") && lastX!==null){
        const dx=e.touches[0].clientX-lastX;
        const dy=e.touches[0].clientY-lastY;
        lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
        yaw -= dx*0.002;
        pitch -= dy*0.002;
        const limit=Math.PI/2.5;
        pitch=Math.max(-limit,Math.min(limit,pitch));
      }
    });
    document.addEventListener("touchend", ()=>{lastX=null;lastY=null;});

    // ---------- GAME LOOP ----------
    const clock=new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const delta=clock.getDelta();
      const speed=1.5*delta;

      // rotation caméra
      camera.rotation.x=pitch;
      camera.rotation.y=yaw;

      // lampe torche suit caméra
      torch.position.copy(camera.position);
      const dir=new THREE.Vector3(0,0,-1).applyEuler(camera.rotation).add(camera.position);
      torch.target.position.copy(dir);

      // déplacement
      const oldPos=camera.position.clone();
      const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
      const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();
      camera.position.addScaledVector(forward,-moveZ*speed*5);
      camera.position.addScaledVector(right,moveX*speed*5);

      // collisions
      const radius=0.5;
      for(const wall of walls){
        const dx=Math.abs(camera.position.x-wall.position.x);
        const dz=Math.abs(camera.position.z-wall.position.z);
        if(dx < CELL/2+radius && dz < CELL/2+radius){
          camera.position.copy(oldPos);
          break;
        }
      }

      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener("resize", ()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  </script>
</body>
</html>








