<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Backrooms Horreur</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        touch-action: none;
      }
      #hud {
        position: absolute;
        top: 10px;
        left: 10px;
        padding: 6px 10px;
        font-family: monospace;
        font-size: 14px;
        color: white;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 6px;
      }
      #joystick {
        position: absolute;
        bottom: 30px;
        left: 30px;
        width: 100px;
        height: 100px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        touch-action: none;
      }
      #stick {
        position: absolute;
        left: 35px;
        top: 35px;
        width: 30px;
        height: 30px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
      }
    </style>
  </head>
  <body>
    <div id="hud">Backrooms : lampe torche + son + collisions</div>
    <div id="joystick"><div id="stick"></div></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0xe6e6d8, 0.02);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0,1.6,0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // ---------------- LIGHTS ----------------
      const ambient = new THREE.AmbientLight(0xffffff, 0.15);
      scene.add(ambient);

      // Lampe torche (SpotLight attachée à la caméra)
      const torch = new THREE.SpotLight(0xffffff, 2, 20, Math.PI/6, 0.3, 1);
      torch.position.set(0, 0, 0);
      torch.target.position.set(0, 0, -1);
      camera.add(torch);
      camera.add(torch.target);
      scene.add(camera);

      // ---------------- AUDIO ----------------
      const listener = new THREE.AudioListener();
      camera.add(listener);

      const sound = new THREE.Audio(listener);
      const audioLoader = new THREE.AudioLoader();
      audioLoader.load(
        "https://cdn.pixabay.com/download/audio/2021/09/13/audio_bf19c9c6d7.mp3?filename=neon-light-buzz-6407.mp3",
        (buffer) => {
          sound.setBuffer(buffer);
          sound.setLoop(true);
          sound.setVolume(0.3);
          sound.play();
        }
      );

      // ---------------- MAP ----------------
      const MAP_W = 40, MAP_H = 40, CELL = 4;
      const loader = new THREE.TextureLoader();

      const wallTex = loader.load("https://ambientcg.com/get?file=Wallpaper001_1K-JPG_Color.jpg");
      wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;

      const floorTex = loader.load("https://ambientcg.com/get?file=Carpet006_1K-JPG_Color.jpg");
      floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
      floorTex.repeat.set(MAP_W/2, MAP_H/2);

      const ceilTex = loader.load("https://ambientcg.com/get?file=CeilingTile001_1K-JPG_Color.jpg");
      ceilTex.wrapS = ceilTex.wrapT = THREE.RepeatWrapping;
      ceilTex.repeat.set(MAP_W/2, MAP_H/2);

      const wallMat = new THREE.MeshStandardMaterial({ map: wallTex });
      const floorMat = new THREE.MeshStandardMaterial({ map: floorTex });
      const ceilMat = new THREE.MeshStandardMaterial({ map: ceilTex });

      const walls = [];
      const wallGeo = new THREE.BoxGeometry(CELL, 3, CELL);

      for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
          if (Math.random() < 0.3 || x === 0 || y === 0 || x === MAP_W-1 || y === MAP_H-1) {
            const wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.set((x - MAP_W/2) * CELL, 1.5, (y - MAP_H/2) * CELL);
            scene.add(wall);
            walls.push(wall);
          }
        }
      }

      const floorGeo = new THREE.PlaneGeometry(MAP_W * CELL, MAP_H * CELL);
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);

      const ceilGeo = new THREE.PlaneGeometry(MAP_W * CELL, MAP_H * CELL);
      const ceiling = new THREE.Mesh(ceilGeo, ceilMat);
      ceiling.rotation.x = Math.PI/2;
      ceiling.position.y = 3;
      scene.add(ceiling);

      // ---------------- JOYSTICK & CAMERA ----------------
      let yaw = 0, pitch = 0;
      let moveX = 0, moveZ = 0;

      const joystick = document.getElementById("joystick");
      const stick = document.getElementById("stick");
      let joyActive = false;
      let joyCenter = { x: 0, y: 0 };

      joystick.addEventListener("touchstart", (e) => {
        joyActive = true;
        const rect = joystick.getBoundingClientRect();
        joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
      });
      joystick.addEventListener("touchend", () => {
        joyActive = false;
        stick.style.left = "35px";
        stick.style.top = "35px";
        moveX = moveZ = 0;
      });
      joystick.addEventListener("touchmove", (e) => {
        if (!joyActive) return;
        const t = e.touches[0];
        const dx = t.clientX - joyCenter.x;
        const dy = t.clientY - joyCenter.y;
        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
        const angle = Math.atan2(dy, dx);
        stick.style.left = 35 + dist * Math.cos(angle) - 15 + "px";
        stick.style.top = 35 + dist * Math.sin(angle) - 15 + "px";
        moveX = dx / 40;
        moveZ = dy / 40;
      });

      let lastTouchX = null, lastTouchY = null;
      document.addEventListener("touchstart", (e) => {
        if (!e.target.closest("#joystick")) {
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
        }
      });
      document.addEventListener("touchmove", (e) => {
        if (!e.target.closest("#joystick") && lastTouchX !== null) {
          const dx = e.touches[0].clientX - lastTouchX;
          const dy = e.touches[0].clientY - lastTouchY;
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
          yaw -= dx * 0.003;
          pitch -= dy * 0.003;
          pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        }
      });
      document.addEventListener("touchend", () => { lastTouchX = null; lastTouchY = null; });

      // ---------------- GAME LOOP ----------------
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const speed = 5 * delta;

        // rotation
        camera.rotation.x = pitch;
        camera.rotation.y = yaw;

        // sauvegarde position avant déplacement
        const oldPos = camera.position.clone();

        // direction
        const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

        // déplacement
        camera.position.addScaledVector(forward, -moveZ * speed * 5);
        camera.position.addScaledVector(right, moveX * speed * 5);

        // COLLISIONS : si trop proche d'un mur → retour en arrière
        const playerRadius = 0.5;
        for (const wall of walls) {
          const dist = wall.position.distanceTo(camera.position);
          if (dist < CELL/2 + playerRadius) {
            camera.position.copy(oldPos);
            break;
          }
        }

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>







