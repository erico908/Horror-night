<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms Horror Game - Three.js</title>
  <style>
    body {
      margin: 0; overflow: hidden; background: #222;
      font-family: Arial, sans-serif;
      color: white;
    }
    #startScreen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #111;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      user-select: none;
    }
    #startScreen h1 {
      font-size: 3em;
      margin-bottom: 20px;
      color: #eec973;
      text-shadow: 0 0 10px #ffaa00;
    }
    #startScreen button {
      padding: 15px 40px;
      font-size: 1.2em;
      cursor: pointer;
      border: none;
      border-radius: 10px;
      background: linear-gradient(45deg, #ffaa00, #ff7700);
      color: black;
      box-shadow: 0 0 10px #ff7700;
      transition: background 0.3s ease;
    }
    #startScreen button:hover {
      background: linear-gradient(45deg, #ffcc33, #ff9900);
      box-shadow: 0 0 20px #ffcc33;
    }
    #info {
      position: absolute; top: 10px; left: 10px;
      z-index: 10; background: rgba(0,0,0,0.5);
      padding: 10px; border-radius: 8px;
      max-width: 300px;
      font-size: 14px;
      user-select: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>Backrooms Horror Game</h1>
    <button id="playBtn">Jouer</button>
  </div>

  <div id="info" style="display:none;">
    <p>
      Contrôlez la lampe torche avec :<br>
      - Clavier (ZQSD) + souris (déplacer souris pour regarder)<br>
      - Manette (stick analogique droit)<br>
      - Mobile (gyroscope)
    </p>
    <p>Le monstre vous suit, essayez de l’éviter dans cette ambiance oppressante...</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let player, monster, monsterSpeed = 0.02;
    let flashlight, flashlightTarget;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    let raycaster;

    // For gamepad support
    let gamepadIndex = null;

    // Gyroscope data (mobile)
    let gyroBeta = 0;
    let gyroGamma = 0;

    let gameStarted = false;

    const infoDiv = document.getElementById('info');
    const startScreen = document.getElementById('startScreen');
    const playBtn = document.getElementById('playBtn');

    playBtn.addEventListener('click', () => {
      startScreen.style.display = 'none';
      infoDiv.style.display = 'block';
      
      // Lock pointer automatically on play
      controls.lock();
      gameStarted = true;
    });

    init();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x252525);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.y = 1.6; // eye height

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Controls & pointer lock
      controls = new THREE.PointerLockControls(camera, document.body);

      // When pointer lock/unlock update info visibility
      controls.addEventListener('lock', () => {
        if(gameStarted) infoDiv.style.display = 'block';
      });

      controls.addEventListener('unlock', () => {
        if(gameStarted) infoDiv.style.display = 'none';
      });

      // Player is abstract, for monster tracking keep position
      player = controls.getObject();

      // Simple floor - yellowish walls for backrooms vibe
      const floorGeometry = new THREE.PlaneGeometry(100, 100);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xeedc82, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // Walls
      const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf3e5ab });

      function createWall(x, y, z, w, h, d) {
        const geo = new THREE.BoxGeometry(w, h, d);
        const wall = new THREE.Mesh(geo, wallMaterial);
        wall.position.set(x, y, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        return wall;
      }

      // Corridor walls
      createWall(0, 1.5, -20, 20, 3, 1);
      createWall(0, 1.5, 20, 20, 3, 1);
      createWall(-10, 1.5, 0, 1, 3, 40);
      createWall(10, 1.5, 0, 1, 3, 40);

      // Monster
      const monsterGeometry = new THREE.BoxGeometry(1, 2, 1);
      const monsterMaterial = new THREE.MeshStandardMaterial({
        color: 0x880000,
        emissive: 0x550000,
        emissiveIntensity: 0.5
      });
      monster = new THREE.Mesh(monsterGeometry, monsterMaterial);
      monster.position.set(0, 1, 10);
      monster.castShadow = true;
      scene.add(monster);

      // Monster light glow
      const monsterLight = new THREE.PointLight(0xff4400, 1, 10);
      monsterLight.position.set(0, 1.5, 0);
      monster.add(monsterLight);

      // Flashlight - spotlight on camera
      flashlight = new THREE.SpotLight(0xffffff, 2, 20, Math.PI / 6, 0.2, 1);
      flashlight.position.set(0, 0, 0);
      flashlight.castShadow = true;
      flashlight.shadow.mapSize.width = 1024;
      flashlight.shadow.mapSize.height = 1024;
      flashlight.shadow.camera.near = 0.1;
      flashlight.shadow.camera.far = 25;
      flashlight.shadow.bias = -0.005;

      camera.add(flashlight);
      camera.add(flashlight.target);
      flashlight.target.position.set(0, 0, -1);

      // Ambient light
      const ambient = new THREE.AmbientLight(0x555555);
      scene.add(ambient);

      raycaster = new THREE.Raycaster();

      window.addEventListener('resize', onWindowResize, false);
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);

      window.addEventListener("gamepadconnected", (e) => {
        gamepadIndex = e.gamepad.index;
        console.log("Gamepad connected:", e.gamepad.id);
      });
      window.addEventListener("gamepaddisconnected", (e) => {
        if(gamepadIndex === e.gamepad.index) gamepadIndex = null;
        console.log("Gamepad disconnected");
      });

      // Mobile gyroscope
      if(window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', (event) => {
          gyroBeta = event.beta;
          gyroGamma = event.gamma;
        }, true);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      if(!gameStarted) return;
      switch(event.code) {
        case 'KeyZ':
        case 'ArrowUp':
          moveForward = true; break;
        case 'KeyS':
        case 'ArrowDown':
          moveBackward = true; break;
        case 'KeyQ':
        case 'ArrowLeft':
          moveLeft = true; break;
        case 'KeyD':
        case 'ArrowRight':
          moveRight = true; break;
      }
    }

    function onKeyUp(event) {
      if(!gameStarted) return;
      switch(event.code) {
        case 'KeyZ':
        case 'ArrowUp':
          moveForward = false; break;
        case 'KeyS':
        case 'ArrowDown':
          moveBackward = false; break;
        case 'KeyQ':
        case 'ArrowLeft':
          moveLeft = false; break;
        case 'KeyD':
        case 'ArrowRight':
          moveRight = false; break;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      if(!gameStarted) {
        renderer.render(scene, camera); // Show the empty scene behind start screen
        return;
      }

      const time = performance.now();
      const delta = (time - prevTime) / 1000;

      if(controls.isLocked === true) {
        // Player Movement
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        const speed = 5.0;

        if(direction.length() > 0) {
          velocity.x -= direction.x * speed * delta;
          velocity.z -= direction.z * speed * delta;
        }

        controls.moveRight(- velocity.x * delta);
        controls.moveForward(- velocity.z * delta);
      }

      // Monster follows player
      const playerPosition = player.position.clone();
      const monsterPosition = monster.position.clone();

      let toPlayerVec = playerPosition.sub(monsterPosition);
      let distance = toPlayerVec.length();

      if(distance > 1) {
        toPlayerVec.normalize();
        monster.position.add(toPlayerVec.multiplyScalar(monsterSpeed));
      }

      // Monster oscillation
      monster.position.y = 1 + 0.1 * Math.sin(time * 0.005);

      // Update flashlight target based on inputs

      // Mobile gyroscope control
      flashlight.target.position.x = THREE.MathUtils.clamp(gyroGamma / 30, -1, 1);
      flashlight.target.position.y = THREE.MathUtils.clamp(-gyroBeta / 30, -1, 1);
      flashlight.target.position.z = -1;

      // Gamepad right stick control
      if(gamepadIndex !== null) {
        const gp = navigator.getGamepads()[gamepadIndex];
        if(gp) {
          let rx = gp.axes[2];
          let ry = gp.axes[3];
          if(Math.abs(rx) < 0.1) rx = 0;
          if(Math.abs(ry) < 0.1) ry = 0;
          flashlight.target.position.x = THREE.MathUtils.clamp(rx, -1, 1);
          flashlight.target.position.y = THREE.MathUtils.clamp(-ry, -1, 1);
          flashlight.target.position.z = -1;
        }
      }

      flashlight.target.position.normalize().multiplyScalar(1);

      prevTime = time;

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
