<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Backrooms - Couleurs simples</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;touch-action:none}
    #hud{position:absolute;left:10px;top:10px;color:#fff;font-family:monospace;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:6px;z-index:10;font-size:13px}
    #joystick{position:absolute;left:18px;bottom:18px;width:84px;height:84px;border-radius:50%;background:rgba(255,255,255,0.06);z-index:9;display:flex;align-items:center;justify-content:center;touch-action:none}
    #stick{width:34px;height:34px;border-radius:50%;background:rgba(255,255,255,0.55);transform:translate(0,0)}
  </style>
</head>
<body>
  <div id="hud">Position: <span id="pos">0,0</span></div>
  <div id="joystick"><div id="stick"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
  /* ---------------- CONFIG ---------------- */
  const MAP_SIZE = 500;
  const CELL_SIZE = 10;
  const WALL_PROB = 0.3;
  const WALK_SPEED = 1.0;      
  const PLAYER_RADIUS = 0.5;

  /* ---------------- THREE SETUP ---------------- */
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 1.7, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  /* ---------------- LIGHTING ---------------- */
  scene.add(new THREE.AmbientLight(0xffffff, 2)); // bien lumineux

  /* ---------------- MATERIALS (COULEURS UNIQUES) ---------------- */
  const floorMat = new THREE.MeshStandardMaterial({ color: 0xccaa33 });  // sol jaune foncé
  const ceilMat  = new THREE.MeshStandardMaterial({ color: 0xffff66 });  // plafond jaune clair
  const wallMat  = new THREE.MeshStandardMaterial({ color: 0xffee33 });  // murs jaune vif

  /* ---------------- FLOOR & CEILING ---------------- */
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), floorMat);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), ceilMat);
  ceiling.rotation.x = Math.PI/2;
  ceiling.position.y = 3;
  scene.add(ceiling);

  /* ---------------- WALLS ---------------- */
  const walls = [];
  for (let x = -MAP_SIZE/2; x < MAP_SIZE/2; x += CELL_SIZE) {
    for (let z = -MAP_SIZE/2; z < MAP_SIZE/2; z += CELL_SIZE) {
      if (Math.random() < WALL_PROB && Math.hypot(x,z) > 20) {
        const wall = new THREE.Mesh(
          new THREE.BoxGeometry(CELL_SIZE, 3, CELL_SIZE),
          wallMat
        );
        wall.position.set(x, 1.5, z);
        scene.add(wall);
        walls.push(wall);
      }
    }
  }

  /* ---------------- JOYSTICK ---------------- */
  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  let joyActive = false, joyCenter = {x:0,y:0}, moveX=0, moveZ=0;
  joystick.addEventListener('touchstart',(e)=>{
    e.preventDefault(); joyActive = true;
    const r = joystick.getBoundingClientRect();
    joyCenter = {x:r.left+r.width/2,y:r.top+r.height/2};
  });
  joystick.addEventListener('touchend',(e)=>{
    e.preventDefault(); joyActive = false; moveX=0; moveZ=0;
    stick.style.transform='translate(0,0)';
  });
  joystick.addEventListener('touchmove',(e)=>{
    e.preventDefault();
    if(!joyActive)return;
    const t=e.touches[0];
    const dx=t.clientX-joyCenter.x, dy=t.clientY-joyCenter.y;
    const max=36;
    const dist=Math.min(Math.sqrt(dx*dx+dy*dy),max);
    const ang=Math.atan2(dy,dx);
    const sx=Math.cos(ang)*dist, sy=Math.sin(ang)*dist;
    stick.style.transform=`translate(${sx}px,${sy}px)`;
    moveX=sx/max; moveZ=-sy/max; // inversion corrigée
  });

  /* ---------------- CAMERA CONTROL ---------------- */
  let yaw=0,pitch=0,lastX=null,lastY=null;
  document.addEventListener('touchstart',(e)=>{
    if(e.target.closest('#joystick'))return;
    lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
  });
  document.addEventListener('touchmove',(e)=>{
    if(e.target.closest('#joystick'))return;
    if(lastX===null)return;
    const dx=e.touches[0].clientX-lastX;
    const dy=e.touches[0].clientY-lastY;
    lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
    yaw-=dx*0.0022; pitch-=dy*0.0022;
    pitch=Math.max(-Math.PI/2.4,Math.min(Math.PI/2.4,pitch));
  });
  document.addEventListener('touchend',()=>{lastX=null;lastY=null;});

  /* ---------------- COLLISIONS ---------------- */
  function collides(pos){
    for(const wall of walls){
      const dx=Math.abs(pos.x-wall.position.x);
      const dz=Math.abs(pos.z-wall.position.z);
      if(dx < CELL_SIZE/2+PLAYER_RADIUS && dz < CELL_SIZE/2+PLAYER_RADIUS){
        return true;
      }
    }
    return false;
  }

  /* ---------------- ANIMATION ---------------- */
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const dt=Math.min(clock.getDelta(),0.05);

    const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
    const right=new THREE.Vector3(forward.z,0,-forward.x);
    let move=new THREE.Vector3();
    move.addScaledVector(forward,moveZ); 
    move.addScaledVector(right,moveX);
    if(move.lengthSq()>0)move.normalize();

    const next=camera.position.clone().addScaledVector(move,WALK_SPEED*dt);
    if(!collides(next))camera.position.copy(next);

    camera.rotation.y=yaw;
    camera.rotation.x=pitch;

    document.getElementById('pos').textContent=`${camera.position.x.toFixed(1)},${camera.position.z.toFixed(1)}`;

    renderer.render(scene,camera);
  }
  animate();

  window.addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
  </script>
</body>
</html>


