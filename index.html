<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms Horror Game - Three.js</title>
  <style>
    body {
      margin: 0; overflow: hidden; background: #222;
      font-family: Arial, sans-serif;
      color: white;
    }
    #info {
      position: absolute; top: 10px; left: 10px;
      z-index: 10; background: rgba(0,0,0,0.5);
      padding: 10px; border-radius: 8px;
      max-width: 300px;
      font-size: 14px;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="info">
    <h3>Backrooms Horror Game</h3>
    <p>
      Contrôlez la lampe torche avec:<br>
      - Clavier (ZQSD) + souris (déplacer souris pour regarder)<br>
      - Manette (stick analogique droit)<br>
      - Mobile (gyroscope)
    </p>
    <p>Le monstre vous suit, essayez de l’éviter dans cette ambiance oppressante...</p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let player, monster, monsterSpeed = 0.02;
    let flashlight, flashlightTarget;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    let raycaster;

    // For gamepad support
    let gamepadIndex = null;

    // Gyroscope data (mobile)
    let gyroBeta = 0;
    let gyroGamma = 0;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x252525);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.y = 1.6; // eye height

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Controls & pointer lock
      controls = new THREE.PointerLockControls(camera, document.body);

      document.body.addEventListener('click', () => {
        controls.lock();
      });

      controls.addEventListener('lock', () => {
        document.getElementById('info').style.display = 'none';
      });

      controls.addEventListener('unlock', () => {
        document.getElementById('info').style.display = 'block';
      });

      // Player is abstract, but for monster tracking keep position
      player = controls.getObject();

      // Simple floor - yellowish walls to replicate backrooms
      const floorGeometry = new THREE.PlaneGeometry(100, 100);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xeedc82, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // Walls (some simple cubes around to simulate corridors)
      const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf3e5ab });

      function createWall(x, y, z, w, h, d) {
        const geo = new THREE.BoxGeometry(w, h, d);
        const wall = new THREE.Mesh(geo, wallMaterial);
        wall.position.set(x, y, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        return wall;
      }

      // Create simple corridor walls
      createWall(0, 1.5, -20, 20, 3, 1);
      createWall(0, 1.5, 20, 20, 3, 1);
      createWall(-10, 1.5, 0, 1, 3, 40);
      createWall(10, 1.5, 0, 1, 3, 40);

      // Monster — simple red box with emissive light for glow
      const monsterGeometry = new THREE.BoxGeometry(1, 2, 1);
      const monsterMaterial = new THREE.MeshStandardMaterial({
        color: 0x880000,
        emissive: 0x550000,
        emissiveIntensity: 0.5
      });
      monster = new THREE.Mesh(monsterGeometry, monsterMaterial);
      monster.position.set(0, 1, 10); // Start behind player
      monster.castShadow = true;
      scene.add(monster);

      // A red point light on monster for glow effect
      const monsterLight = new THREE.PointLight(0xff4400, 1, 10);
      monsterLight.position.set(0, 1.5, 0);
      monster.add(monsterLight);

      // Flashlight (spotlight attached to camera)
      flashlight = new THREE.SpotLight(0xffffff, 2, 20, Math.PI / 6, 0.2, 1);
      flashlight.position.set(0, 0, 0);
      flashlight.castShadow = true;
      flashlight.shadow.mapSize.width = 1024;
      flashlight.shadow.mapSize.height = 1024;
      flashlight.shadow.camera.near = 0.1;
      flashlight.shadow.camera.far = 25;
      flashlight.shadow.bias = -0.005;

      camera.add(flashlight);
      camera.add(flashlight.target);
      flashlight.target.position.set(0, 0, -1);

      // Ambient light for subtle overall lighting
      const ambient = new THREE.AmbientLight(0x555555);
      scene.add(ambient);

      // Raycaster for collision and light interaction
      raycaster = new THREE.Raycaster();

      // Resize handler
      window.addEventListener('resize', onWindowResize, false);

      // Keyboard events
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);

      // Mouse movement - pointer lock controls handle camera rotation automatically

      // Gamepad connection handler
      window.addEventListener("gamepadconnected", (e) => {
        gamepadIndex = e.gamepad.index;
        console.log("Gamepad connecté:", e.gamepad.id);
      });
      window.addEventListener("gamepaddisconnected", (e) => {
        if(gamepadIndex === e.gamepad.index) gamepadIndex = null;
        console.log("Gamepad déconnecté");
      });

      // Mobile Gyroscope
      if(window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', (event) => {
          gyroBeta = event.beta; // [-180,180], front-back tilt
          gyroGamma = event.gamma; // [-90,90], left-right tilt
        }, true);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      switch(event.code) {
        case 'KeyZ':
        case 'ArrowUp':
          moveForward = true; break;
        case 'KeyS':
        case 'ArrowDown':
          moveBackward = true; break;
        case 'KeyQ':
        case 'ArrowLeft':
          moveLeft = true; break;
        case 'KeyD':
        case 'ArrowRight':
          moveRight = true; break;
      }
    }

    function onKeyUp(event) {
      switch(event.code) {
        case 'KeyZ':
        case 'ArrowUp':
          moveForward = false; break;
        case 'KeyS':
        case 'ArrowDown':
          moveBackward = false; break;
        case 'KeyQ':
        case 'ArrowLeft':
          moveLeft = false; break;
        case 'KeyD':
        case 'ArrowRight':
          moveRight = false; break;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();
      const delta = (time - prevTime) / 1000;

      if(controls.isLocked === true) {

        // Player Movement
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        const speed = 5.0;

        if(direction.length() > 0) {
          velocity.x -= direction.x * speed * delta;
          velocity.z -= direction.z * speed * delta;
        }

        controls.moveRight(- velocity.x * delta);
        controls.moveForward(- velocity.z * delta);

      }

      // Monster follow player
      const playerPosition = player.position.clone();
      const monsterPosition = monster.position.clone();

      let toPlayerVec = playerPosition.sub(monsterPosition);
      let distance = toPlayerVec.length();

      if(distance > 1) {
        toPlayerVec.normalize();
        monster.position.add(toPlayerVec.multiplyScalar(monsterSpeed));
      }

      // Monster simple oscillation for creepy effect
      monster.position.y = 1 + 0.1 * Math.sin(time * 0.005);

      // Update flashlight target based on inputs

      // Mobile gyro controls lamp torch direction
      // Small mapping of beta/gamma to flashlight target angles on camera local z axis
      flashlight.target.position.x = THREE.MathUtils.clamp(gyroGamma / 30, -1, 1);
      flashlight.target.position.y = THREE.MathUtils.clamp(-gyroBeta / 30, -1, 1);
      flashlight.target.position.z = -1;

      // Gamepad right stick controls flashlight direction
      if(gamepadIndex !== null) {
        const gp = navigator.getGamepads()[gamepadIndex];
        if(gp) {
          // axes 2 (X), 3 (Y) for right stick (common)
          let rx = gp.axes[2];
          let ry = gp.axes[3];
          // Apply deadzone
          if(Math.abs(rx) < 0.1) rx = 0;
          if(Math.abs(ry) < 0.1) ry = 0;
          flashlight.target.position.x = THREE.MathUtils.clamp(rx, -1, 1);
          flashlight.target.position.y = THREE.MathUtils.clamp(-ry, -1, 1);
          flashlight.target.position.z = -1;
        }
      }

      // Clamp flashlight target more to center based on mouse movement (already included in PointerLockControls)

      // Keep flashlight target normalized direction
      flashlight.target.position.normalize().multiplyScalar(1);

      prevTime = time;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
