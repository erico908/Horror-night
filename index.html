<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms FPS + Monster IA</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none;}
    #joystick {
      position:absolute; left:20px; bottom:30px;
      width:120px; height:120px; border-radius:50%;
      background: rgba(255,255,255,0.06);
      border: 2px solid rgba(255,255,255,0.12);
      touch-action:none;
    }
    #stick {
      position:absolute; width:40px; height:40px; border-radius:50%;
      background: rgba(255,255,255,0.6);
      left:40px; top:40px;
      box-shadow:0 1px 6px rgba(0,0,0,0.6);
      transition: left 0.02s linear, top 0.02s linear;
    }
    #sprintBtn {
      position:absolute; right:25px; bottom:40px;
      width:90px; height:90px; border-radius:50%;
      background: rgba(255,255,255,0.12);
      border: 2px solid rgba(255,255,255,0.25);
      color:white; font-size:18px; text-align:center; line-height:90px;
      user-select:none;
    }
    #gameOver {
      position: absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.8); color: #fff; font-family: monospace; font-size: 30px; z-index: 999;
      display: none; flex-direction: column;
    }
    #gameOver button { margin-top: 16px; padding:10px 18px; font-size:16px; }
  </style>
</head>
<body>
  <div id="joystick"><div id="stick"></div></div>
  <div id="sprintBtn">Sprint</div>
  <div id="gameOver"><div>ðŸ’€ Tu es mort...</div><button id="restartBtn">Recommencer</button></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  // ---------------- CONFIG ----------------
  const MAP_HALF = 80;
  const CELL = 10;
  const PLAYER_HEIGHT = 1.6;
  const PLAYER_RADIUS = 0.5;
  const BASE_WALK_SPEED = 2.5;
  const SPRINT_MULT = 2.0;
  const CAMERA_SENSITIVITY = 0.0035;
  const PITCH_LIMIT = Math.PI * 0.47;
  const JOY_MAX = 60, JOY_DEADZONE = 0.15;

  // Monster config (tweakable)
  const MONSTER_ON_DURATION = 60.0;   // seconds visible & active
  const MONSTER_OFF_DURATION = 60.0;  // seconds invisible
  const MONSTER_SPEED = 1.2;          // movement speed (m/s)
  const MONSTER_MIN_SPAWN_DIST = 20;
  const MONSTER_MAX_SPAWN_DIST = 40;
  const MONSTER_GROWL_DIST = 8.0;     // distance to start growl

  // ---------------- RENDER & SCENE ----------------
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0xe6e6d8, 0.004);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  // clamp pixel ratio to avoid overwork on slower devices
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.25));
  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x000000,1);
  document.body.appendChild(renderer.domElement);

  // FPS camera system (yaw/pitch objects)
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.rotation.order = 'YXZ';
  const yawObject = new THREE.Object3D();
  const pitchObject = new THREE.Object3D();
  yawObject.add(pitchObject);
  pitchObject.add(camera);
  yawObject.position.set(0, PLAYER_HEIGHT, 0);
  scene.add(yawObject);

  // ---------------- TEXTURES ----------------
  const loader = new THREE.TextureLoader();
  const texFloor = loader.load("https://ambientcg.com/get?file=Carpet006_1K_Color.jpg", (t)=>{ t.anisotropy = Math.min(4, renderer.capabilities.getMaxAnisotropy()); });
  texFloor.wrapS = texFloor.wrapT = THREE.RepeatWrapping; texFloor.repeat.set(60,60);
  const texWall = loader.load("https://ambientcg.com/get?file=Wallpaper001_1K_Color.jpg");
  texWall.wrapS = texWall.wrapT = THREE.RepeatWrapping; texWall.repeat.set(4,2);
  const texCeil = loader.load("https://ambientcg.com/get?file=CeilingTile001_1K_Color.jpg");
  texCeil.wrapS = texCeil.wrapT = THREE.RepeatWrapping; texCeil.repeat.set(60,60);

  // floor & ceiling
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF*2, MAP_HALF*2), new THREE.MeshStandardMaterial({map:texFloor}));
  floor.rotation.x = -Math.PI/2; scene.add(floor);
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF*2, MAP_HALF*2), new THREE.MeshStandardMaterial({map:texCeil}));
  ceiling.position.y = 3; ceiling.rotation.x = Math.PI/2; scene.add(ceiling);

  // ---------------- WALLS (render optimized with InstancedMesh) ----------------
  // we'll keep a light-weight positions array for collisions (gameplay), and render via instancing
  const wallPositions = [];
  const wallGeo = new THREE.BoxGeometry(CELL,3,CELL);
  const wallMat = new THREE.MeshStandardMaterial({map:texWall});

  for (let x = -MAP_HALF + CELL/2; x <= MAP_HALF - CELL/2; x += CELL) {
    for (let z = -MAP_HALF + CELL/2; z <= MAP_HALF - CELL/2; z += CELL) {
      const isBorder = Math.abs(x) > MAP_HALF - CELL*1.5 || Math.abs(z) > MAP_HALF - CELL*1.5;
      if (isBorder || Math.random() > 0.82) {
        wallPositions.push({x: x, z: z});
      }
    }
  }

  // Create an InstancedMesh for walls (single draw call)
  const instancedWalls = new THREE.InstancedMesh(wallGeo, wallMat, wallPositions.length);
  const dummy = new THREE.Object3D();
  for (let i = 0; i < wallPositions.length; i++) {
    dummy.position.set(wallPositions[i].x, 1.5, wallPositions[i].z);
    dummy.updateMatrix();
    instancedWalls.setMatrixAt(i, dummy.matrix);
  }
  scene.add(instancedWalls);
  instancedWalls.instanceMatrix.needsUpdate = true;

  // ---------------- LIGHTS (kept modest for perf) ----------------
  scene.add(new THREE.AmbientLight(0xffffe0,0.45));
  const neonLights = [];
  for (let i=-60;i<=60;i+=30){
    for (let j=-60;j<=60;j+=30){
      const l = new THREE.PointLight(0xffffcc, 0.65, 22, 2.2);
      l.position.set(i, 2.8, j);
      scene.add(l); neonLights.push(l);
    }
  }
  function updateNeonFlicker(t){
    neonLights.forEach((l, idx) => {
      const base = 0.7 + Math.sin(t * 3.0 + idx) * 0.05;
      const spike = (Math.random() > 0.997) ? 1.6 : 1.0;
      l.intensity = base * spike;
    });
  }

  // ---------------- AUDIO ----------------
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const footstep = new THREE.Audio(listener);
  const audioLoader = new THREE.AudioLoader();
  audioLoader.load("https://cdn.pixabay.com/download/audio/2021/08/04/audio_b64f3a542a.mp3?filename=footstep-carpet-1-6553.mp3",
    (buf)=>{ footstep.setBuffer(buf); footstep.setLoop(true); footstep.setVolume(0.45); },
    undefined, ()=>{ /* ignore load errors */ });

  // monster growl
  const growl = new THREE.Audio(listener);
  audioLoader.load("https://cdn.pixabay.com/download/audio/2021/08/04/audio_4b64b0fcd2.mp3?filename=neon-light-hum-14213.mp3",
    (buf)=>{ growl.setBuffer(buf); growl.setLoop(true); growl.setVolume(0.45); },
    undefined, ()=>{/* ignore */});

  // ---------------- INPUT & UI ----------------
  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  const sprintBtn = document.getElementById('sprintBtn');
  const gameOverDiv = document.getElementById('gameOver');
  const restartBtn = document.getElementById('restartBtn');

  let yaw = 0, pitch = 0;
  let moveX = 0, moveZ = 0;
  let joyTouchId = null, joyCenter = {x:0,y:0}, joyActive=false;
  let camTouchId = null, lastCamX=0, lastCamY=0;
  let isSprinting = false;
  let gameOver = false;

  // joystick handling (multi-touch friendly, normalized)
  joystick.addEventListener('touchstart', (ev)=> {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (joyTouchId === null) {
        joyTouchId = t.identifier; joyActive = true;
        const r = joystick.getBoundingClientRect();
        joyCenter.x = r.left + r.width/2;
        joyCenter.y = r.top + r.height/2;
      }
    }
  }, {passive:false});

  joystick.addEventListener('touchmove', (ev)=> {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (t.identifier === joyTouchId && joyActive) {
        const dx = t.clientX - joyCenter.x;
        const dy = t.clientY - joyCenter.y;
        const maxDist = JOY_MAX;
        let dist = Math.hypot(dx, dy);
        if (dist > maxDist) dist = maxDist;
        const ang = Math.atan2(dy, dx);
        // visual stick
        stick.style.left = `${(60 - 20) + dist * Math.cos(ang)}px`;
        stick.style.top  = `${(60 - 20) + dist * Math.sin(ang)}px`;
        // normalized
        let nx = dx / maxDist, ny = dy / maxDist;
        let len = Math.hypot(nx, ny);
        if (len < JOY_DEADZONE) { moveX = 0; moveZ = 0; }
        else { nx /= len; ny /= len; moveX = nx; moveZ = -ny; } // forward = -ny
      }
    }
  }, {passive:false});

  joystick.addEventListener('touchend', (ev)=> {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (t.identifier === joyTouchId) {
        joyTouchId = null; joyActive = false; moveX = 0; moveZ = 0;
        stick.style.left = "40px"; stick.style.top = "40px";
      }
    }
  }, {passive:false});

  // camera touch (separate finger)
  document.addEventListener('touchstart', (ev)=> {
    for (const t of ev.changedTouches) {
      if (t.target && t.target.closest && t.target.closest('#joystick')) continue;
      if (t.target && t.target.closest && t.target.closest('#sprintBtn')) continue;
      if (camTouchId === null) { camTouchId = t.identifier; lastCamX = t.clientX; lastCamY = t.clientY; }
    }
  }, {passive:true});

  document.addEventListener('touchmove', (ev)=> {
    for (const t of ev.changedTouches) {
      if (t.identifier === camTouchId) {
        const dx = t.clientX - lastCamX; const dy = t.clientY - lastCamY;
        lastCamX = t.clientX; lastCamY = t.clientY;
        yaw -= dx * CAMERA_SENSITIVITY; pitch -= dy * CAMERA_SENSITIVITY;
        pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      }
    }
  }, {passive:true});

  document.addEventListener('touchend', (ev)=> {
    for (const t of ev.changedTouches) {
      if (t.identifier === camTouchId) { camTouchId = null; }
    }
  }, {passive:true});

  // sprint button
  sprintBtn.addEventListener('touchstart', (e)=> { e.preventDefault(); isSprinting = true; }, {passive:false});
  sprintBtn.addEventListener('touchend',   (e)=> { e.preventDefault(); isSprinting = false; }, {passive:false});
  // desktop mouse/keyboard helpers (optional)
  let mouseDown=false, lastMouseX=0,lastMouseY=0;
  document.addEventListener('mousedown', (e)=> { mouseDown=true; lastMouseX=e.clientX; lastMouseY=e.clientY; });
  document.addEventListener('mousemove', (e)=> { if(!mouseDown) return; const dx=e.clientX-lastMouseX, dy=e.clientY-lastMouseY; lastMouseX=e.clientX; lastMouseY=e.clientY; yaw -= dx * CAMERA_SENSITIVITY * 1.2; pitch -= dy * CAMERA_SENSITIVITY * 1.2; pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch)); });
  document.addEventListener('mouseup', ()=> mouseDown=false);
  const keys = {}; window.addEventListener('keydown', (e)=> keys[e.code]=true); window.addEventListener('keyup', (e)=> keys[e.code]=false);

  // restart button
  restartBtn.addEventListener('click', ()=> location.reload());

  // ---------------- MONSTER (IA) ----------------
  const monsterGeom = new THREE.BoxGeometry(1.0, 2.0, 1.0);
  const monsterMat = new THREE.MeshStandardMaterial({ color: 0x880000, emissive: 0x220000 });
  const monster = new THREE.Mesh(monsterGeom, monsterMat);
  monster.position.set(0, 1.0, 0);
  monster.visible = false;
  scene.add(monster);

  let monsterState = 'off'; // 'off' or 'on'
  let monsterTimer = 0;
  let monsterGrowlPlaying = false;
  let gameOverFlag = false;

  // helper: test collision against wallPositions for a candidate pos (x,z)
  function collidesWithWalls(x, z) {
    for (let i = 0; i < wallPositions.length; i++) {
      const p = wallPositions[i];
      const dx = Math.abs(x - p.x);
      const dz = Math.abs(z - p.z);
      if (dx < CELL/2 + PLAYER_RADIUS && dz < CELL/2 + PLAYER_RADIUS) return true;
    }
    return false;
  }

  // spawn monster at a valid pos away from player
  function spawnMonsterAwayFromPlayer() {
    const playerPos = yawObject.position;
    for (let attempt = 0; attempt < 40; attempt++) {
      const angle = Math.random() * Math.PI * 2;
      const dist = MONSTER_MIN_SPAWN_DIST + Math.random() * (MONSTER_MAX_SPAWN_DIST - MONSTER_MIN_SPAWN_DIST);
      const x = playerPos.x + Math.cos(angle) * dist;
      const z = playerPos.z + Math.sin(angle) * dist;
      // within bounds?
      const bound = MAP_HALF - 2;
      if (x < -bound || x > bound || z < -bound || z > bound) continue;
      if (!collidesWithWalls(x, z)) {
        monster.position.set(x, 1.0, z);
        return;
      }
    }
    // fallback: place behind player by MONSTER_MAX_SPAWN_DIST
    const fallbackAngle = Math.random() * Math.PI * 2;
    const fx = playerPos.x + Math.cos(fallbackAngle) * (MONSTER_MIN_SPAWN_DIST + 5);
    const fz = playerPos.z + Math.sin(fallbackAngle) * (MONSTER_MIN_SPAWN_DIST + 5);
    monster.position.set(fx, 1.0, fz);
  }

  function triggerGameOver() {
    if (gameOverFlag) return;
    gameOverFlag = true;
    // show overlay, stop audio
    gameOverDiv.style.display = 'flex';
    try { sound && sound.pause(); } catch(e){}
    try { footstep && footstep.pause(); } catch(e){}
    // freeze movement: we set flags so animate stops moving player (we won't stop render)
  }

  function updateMonster(dt) {
    if (gameOverFlag) return;

    monsterTimer += dt;

    if (monsterState === 'off') {
      if (monsterTimer >= MONSTER_OFF_DURATION) {
        // turn ON
        monsterState = 'on';
        monsterTimer = 0;
        monster.visible = true;
        spawnMonsterAwayFromPlayer();
      }
    } else {
      // state on
      if (monsterTimer >= MONSTER_ON_DURATION) {
        monsterState = 'off';
        monsterTimer = 0;
        monster.visible = false;
        if (growl.isPlaying) growl.stop();
        monsterGrowlPlaying = false;
        return; // nothing to do while turning off
      }

      // pursue player
      const target = new THREE.Vector3(yawObject.position.x, monster.position.y, yawObject.position.z);
      const dir = new THREE.Vector3().subVectors(target, monster.position);
      dir.y = 0;
      const distToPlayer = dir.length();
      if (distToPlayer > 0.001) dir.normalize();
      // propose next position
      const step = Math.min(MONSTER_SPEED * dt, distToPlayer);
      let nextPos = monster.position.clone().add(dir.clone().multiplyScalar(step));

      // if next collides with wall or out of bounds -> try simple steering (perpendicular)
      let collision = false;
      if (collidesWithWalls(nextPos.x, nextPos.z)) collision = true;
      const bound = MAP_HALF - 1.0;
      if (nextPos.x < -bound || nextPos.x > bound || nextPos.z < -bound || nextPos.z > bound) collision = true;

      if (collision) {
        // try perpendicular offsets
        const perp = new THREE.Vector3(-dir.z, 0, dir.x); // one side
        let tried = false;
        for (let s = 0; s < 2; s++) {
          const sign = s === 0 ? 1 : -1;
          const alt = monster.position.clone().add(dir.clone().multiplyScalar(step * 0.8)).add(perp.clone().multiplyScalar(sign * step * 0.9));
          if (!collidesWithWalls(alt.x, alt.z) && Math.abs(alt.x) <= bound && Math.abs(alt.z) <= bound) {
            nextPos = alt;
            tried = true;
            break;
          }
        }
        if (!tried) {
          // can't move - small jitter to avoid locking
          nextPos = monster.position.clone();
        }
      }

      monster.position.copy(nextPos);
      // gentle float for spooky effect
      const bob = Math.sin(performance.now() * 0.002) * 0.12;
      monster.position.y = 1.0 + bob;

      // growl handling
      if (distToPlayer < MONSTER_GROWL_DIST) {
        if (!monsterGrowlPlaying && growl.isBuffer) { growl.play(); monsterGrowlPlaying = true; }
      } else {
        if (monsterGrowlPlaying && growl.isPlaying) { growl.stop(); monsterGrowlPlaying = false; }
      }

      // game over check
      if (distToPlayer < 1.5) {
        triggerGameOver();
      }
    }
  }

  // ---------------- MAIN LOOP ----------------
  const clock = new THREE.Clock();
  let lastFootstepState = false;

  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.elapsedTime;

    // neon flicker
    updateNeonFlicker(t);

    // apply rotations
    pitchObject.rotation.x = pitch;
    yawObject.rotation.y = yaw;
    yawObject.position.y = PLAYER_HEIGHT; // keep player height fixed

    // keyboard fallback mapping
    let kbForward = 0, kbStrafe = 0;
    if (keys['KeyW'] || keys['KeyZ']) kbForward += 1;
    if (keys['KeyS']) kbForward -= 1;
    if (keys['KeyD']) kbStrafe += 1;
    if (keys['KeyA'] || keys['KeyQ']) kbStrafe -= 1;

    const finalForward = Math.abs(moveZ) > 0.01 ? moveZ : kbForward;
    const finalStrafe = Math.abs(moveX) > 0.01 ? moveX : kbStrafe;

    // compute movement (respect sprint)
    const currSpeed = (isSprinting ? BASE_WALK_SPEED * SPRINT_MULT : BASE_WALK_SPEED);
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(yawObject.quaternion).setY(0).normalize();
    const right = new THREE.Vector3(1,0,0).applyQuaternion(yawObject.quaternion).setY(0).normalize();
    const moveVec = forward.clone().multiplyScalar(finalForward * currSpeed * dt)
                     .add(right.clone().multiplyScalar(finalStrafe * currSpeed * dt));

    // save old position
    const oldPos = yawObject.position.clone();
    if (!gameOver) {
      yawObject.position.add(moveVec);
    }

    // clamp bounding box
    const bound = MAP_HALF - PLAYER_RADIUS - 0.1;
    if (yawObject.position.x < -bound || yawObject.position.x > bound || yawObject.position.z < -bound || yawObject.position.z > bound) {
      yawObject.position.copy(oldPos);
    } else {
      // collisions with walls (using wallPositions array)
      for (let i = 0; i < wallPositions.length; i++) {
        const p = wallPositions[i];
        const dx = Math.abs(yawObject.position.x - p.x);
        const dz = Math.abs(yawObject.position.z - p.z);
        if (dx < CELL/2 + PLAYER_RADIUS && dz < CELL/2 + PLAYER_RADIUS) {
          yawObject.position.copy(oldPos);
          break;
        }
      }
    }

    // footsteps audio management
    const walking = !gameOver && (Math.abs(finalForward) > 0.01 || Math.abs(finalStrafe) > 0.01);
    if (walking && !footstep.isPlaying) footstep.play();
    if (!walking && footstep.isPlaying) footstep.pause();

    // call monster update (IA) BEFORE render
    updateMonster(dt);

    renderer.render(scene, camera);
  }
  animate();

  // ---------------- RESIZE ----------------
  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  </script>
</body>
</html>







