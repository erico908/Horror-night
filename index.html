<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms FPS</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none;}
    #joystick {
      position:absolute; left:20px; bottom:30px;
      width:120px; height:120px; border-radius:50%;
      background: rgba(255,255,255,0.06);
      border: 2px solid rgba(255,255,255,0.12);
      touch-action:none;
    }
    #stick {
      position:absolute; width:40px; height:40px; border-radius:50%;
      background: rgba(255,255,255,0.6);
      left:40px; top:40px;
      box-shadow:0 1px 6px rgba(0,0,0,0.6);
      transition: left 0.02s linear, top 0.02s linear;
    }
    #sprintBtn {
      position:absolute; right:25px; bottom:40px;
      width:90px; height:90px; border-radius:50%;
      background: rgba(255,255,255,0.15);
      border: 2px solid rgba(255,255,255,0.25);
      color:white; font-size:18px; text-align:center; line-height:90px;
      user-select:none;
    }
  </style>
</head>
<body>
  <div id="joystick"><div id="stick"></div></div>
  <div id="sprintBtn">Sprint</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  // ---------- CONFIG ----------
  const MAP_HALF = 80;
  const CELL = 10;
  const PLAYER_HEIGHT = 1.6;
  const PLAYER_RADIUS = 0.5;
  const BASE_WALK_SPEED = 2.5;
  const SPRINT_MULT = 2.0;
  const CAMERA_SENSITIVITY = 0.0035;
  const PITCH_LIMIT = Math.PI * 0.47;
  const JOY_MAX = 60, JOY_DEADZONE = 0.15; // joystick plus grand

  // ---------- SCENE ----------
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0xe6e6d8, 0.004); // plus épais = optimisation

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x000000,1);
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.rotation.order = 'YXZ';
  const yawObject = new THREE.Object3D();
  const pitchObject = new THREE.Object3D();
  yawObject.add(pitchObject);
  pitchObject.add(camera);
  yawObject.position.set(0, PLAYER_HEIGHT, 0);
  scene.add(yawObject);

  // ---------- TEXTURES ----------
  const loader = new THREE.TextureLoader();
  const texFloor = loader.load("https://ambientcg.com/get?file=Carpet006_1K_Color.jpg");
  texFloor.wrapS = texFloor.wrapT = THREE.RepeatWrapping; texFloor.repeat.set(60,60);
  const texWall = loader.load("https://ambientcg.com/get?file=Wallpaper001_1K_Color.jpg");
  texWall.wrapS = texWall.wrapT = THREE.RepeatWrapping; texWall.repeat.set(4,2);
  const texCeil = loader.load("https://ambientcg.com/get?file=CeilingTile001_1K_Color.jpg");
  texCeil.wrapS = texCeil.wrapT = THREE.RepeatWrapping; texCeil.repeat.set(60,60);

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF*2, MAP_HALF*2), new THREE.MeshStandardMaterial({map:texFloor}));
  floor.rotation.x = -Math.PI/2; scene.add(floor);
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF*2, MAP_HALF*2), new THREE.MeshStandardMaterial({map:texCeil}));
  ceiling.position.y = 3; ceiling.rotation.x = Math.PI/2; scene.add(ceiling);

  // murs
  const walls = [];
  const wallGeo = new THREE.BoxGeometry(CELL,3,CELL);
  const wallMat = new THREE.MeshStandardMaterial({map:texWall});
  for (let x=-MAP_HALF+CELL/2; x<=MAP_HALF-CELL/2; x+=CELL){
    for (let z=-MAP_HALF+CELL/2; z<=MAP_HALF-CELL/2; z+=CELL){
      const isBorder = Math.abs(x)>MAP_HALF-CELL*1.5 || Math.abs(z)>MAP_HALF-CELL*1.5;
      if(isBorder || Math.random()>0.82){
        const w = new THREE.Mesh(wallGeo, wallMat);
        w.position.set(x,1.5,z);
        scene.add(w); walls.push(w);
      }
    }
  }

  // lumières optimisées
  scene.add(new THREE.AmbientLight(0xffffe0,0.45));
  for(let i=-60;i<=60;i+=30){
    for(let j=-60;j<=60;j+=30){
      const l=new THREE.PointLight(0xffffcc,0.65,22,2.5);
      l.position.set(i,2.8,j);
      scene.add(l);
    }
  }

  // ---------- AUDIO ----------
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const footstep = new THREE.Audio(listener);
  new THREE.AudioLoader().load("https://cdn.pixabay.com/download/audio/2021/08/04/audio_b64f3a542a.mp3?filename=footstep-carpet-1-6553.mp3",
    (buf)=>{ footstep.setBuffer(buf); footstep.setLoop(true); footstep.setVolume(0.45); });

  // ---------- INPUT ----------
  let yaw=0, pitch=0;
  let moveX=0, moveZ=0;
  let isSprinting=false;

  // joystick
  let joyTouchId=null, joyCenter={x:0,y:0}, joyActive=false;
  const joystick=document.getElementById("joystick");
  const stick=document.getElementById("stick");

  joystick.addEventListener("touchstart",e=>{
    const t=e.changedTouches[0]; joyTouchId=t.identifier; joyActive=true;
    const r=joystick.getBoundingClientRect();
    joyCenter={x:r.left+r.width/2,y:r.top+r.height/2};
  });
  joystick.addEventListener("touchmove",e=>{
    for(const t of e.changedTouches){
      if(t.identifier===joyTouchId && joyActive){
        const dx=t.clientX-joyCenter.x, dy=t.clientY-joyCenter.y;
        const dist=Math.min(Math.hypot(dx,dy),JOY_MAX);
        const ang=Math.atan2(dy,dx);
        stick.style.left=`${60+dist*Math.cos(ang)-20}px`;
        stick.style.top =`${60+dist*Math.sin(ang)-20}px`;
        let nx=dx/JOY_MAX, ny=dy/JOY_MAX, len=Math.hypot(nx,ny);
        if(len<JOY_DEADZONE){ moveX=0; moveZ=0; }
        else{ nx/=len; ny/=len; moveX=nx; moveZ=-ny; }
      }
    }
  });
  joystick.addEventListener("touchend",e=>{
    for(const t of e.changedTouches){
      if(t.identifier===joyTouchId){ joyActive=false; joyTouchId=null; moveX=0; moveZ=0;
        stick.style.left="40px"; stick.style.top="40px"; }
    }
  });

  // caméra tactile
  let camTouchId=null,lastX=0,lastY=0;
  document.addEventListener("touchstart",e=>{
    for(const t of e.changedTouches){
      if(!t.target.closest("#joystick") && camTouchId===null && !t.target.closest("#sprintBtn")){
        camTouchId=t.identifier; lastX=t.clientX; lastY=t.clientY;
      }
    }
  });
  document.addEventListener("touchmove",e=>{
    for(const t of e.changedTouches){
      if(t.identifier===camTouchId){
        const dx=t.clientX-lastX, dy=t.clientY-lastY;
        lastX=t.clientX; lastY=t.clientY;
        yaw-=dx*CAMERA_SENSITIVITY; pitch-=dy*CAMERA_SENSITIVITY;
        pitch=Math.max(-PITCH_LIMIT,Math.min(PITCH_LIMIT,pitch));
      }
    }
  });
  document.addEventListener("touchend",e=>{
    for(const t of e.changedTouches){ if(t.identifier===camTouchId){camTouchId=null;} }
  });

  // bouton sprint
  const sprintBtn=document.getElementById("sprintBtn");
  sprintBtn.addEventListener("touchstart",()=>{ isSprinting=true; });
  sprintBtn.addEventListener("touchend",()=>{ isSprinting=false; });

  // ---------- LOOP ----------
  const clock=new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const dt=clock.getDelta();

    pitchObject.rotation.x=pitch;
    yawObject.rotation.y=yaw;
    yawObject.position.y=PLAYER_HEIGHT;

    const speed=(isSprinting? BASE_WALK_SPEED*SPRINT_MULT:BASE_WALK_SPEED)*dt;

    const forward=new THREE.Vector3(0,0,-1).applyQuaternion(yawObject.quaternion).setY(0).normalize();
    const right=new THREE.Vector3(1,0,0).applyQuaternion(yawObject.quaternion).setY(0).normalize();
    const deltaPos=forward.multiplyScalar(moveZ*speed).add(right.multiplyScalar(moveX*speed));

    const oldPos=yawObject.position.clone();
    yawObject.position.add(deltaPos);

    const bound=MAP_HALF-PLAYER_RADIUS-0.1;
    if(Math.abs(yawObject.position.x)>bound||Math.abs(yawObject.position.z)>bound){yawObject.position.copy(oldPos);}
    for(const w of walls){
      const dx=Math.abs(yawObject.position.x-w.position.x);
      const dz=Math.abs(yawObject.position.z-w.position.z);
      if(dx<CELL/2+PLAYER_RADIUS && dz<CELL/2+PLAYER_RADIUS){yawObject.position.copy(oldPos);break;}
    }

    const walking=(Math.abs(moveX)>0.01||Math.abs(moveZ)>0.01);
    if(walking){ if(!footstep.isPlaying) footstep.play(); }
    else{ if(footstep.isPlaying) footstep.pause(); }

    renderer.render(scene,camera);
  }
  animate();

  window.addEventListener("resize",()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
  </script>
</body>
</html>






