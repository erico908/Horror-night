<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms FPS</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #joystick {
      position: absolute; bottom: 30px; left: 30px;
      width: 100px; height: 100px; border-radius: 50%;
      background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
      touch-action: none;
    }
    #stick {
      position: absolute; left: 40px; top: 40px;
      width: 40px; height: 40px; border-radius: 50%;
      background: rgba(255,255,255,0.5);
    }
    #sprintBtn {
      position: absolute; bottom: 40px; right: 40px;
      width: 80px; height: 80px; border-radius: 50%;
      background: rgba(255,0,0,0.4); border: 2px solid rgba(255,255,255,0.6);
      color: white; font-size: 18px; font-weight: bold;
      display: flex; align-items: center; justify-content: center;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="joystick"><div id="stick"></div></div>
  <div id="sprintBtn">RUN</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    // ---------- SCENE ----------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0, 1.6, 0);

    // ---------- TEXTURES ----------
    const loader = new THREE.TextureLoader();
    const texFloor = loader.load("https://ambientcg.com/get?file=Carpet006_1K_Color.jpg");
    texFloor.wrapS = texFloor.wrapT = THREE.RepeatWrapping;
    texFloor.repeat.set(20,20);

    const texWall = loader.load("https://ambientcg.com/get?file=Wallpaper001_1K_Color.jpg");
    texWall.wrapS = texWall.wrapT = THREE.RepeatWrapping;
    texWall.repeat.set(10,4);

    const texCeil = loader.load("https://ambientcg.com/get?file=CeilingTile001_1K_Color.jpg");
    texCeil.wrapS = texCeil.wrapT = THREE.RepeatWrapping;
    texCeil.repeat.set(20,20);

    // Sol
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({map: texFloor}));
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // Plafond
    const ceil = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({map: texCeil}));
    ceil.rotation.x = Math.PI/2;
    ceil.position.y = 3;
    scene.add(ceil);

    // ---------- MURS ----------
    const walls = [];
    const CELL = 10;
    for (let x=-50; x<=50; x+=CELL) {
      for (let z=-50; z<=50; z+=CELL) {
        if (Math.random() > 0.75) {
          const wall = new THREE.Mesh(
            new THREE.BoxGeometry(CELL,3,CELL),
            new THREE.MeshStandardMaterial({map: texWall})
          );
          wall.position.set(x,1.5,z);
          scene.add(wall);
          walls.push(wall);
        }
      }
    }

    // ---------- LUMIÃˆRES ----------
    scene.add(new THREE.AmbientLight(0xffffe0, 0.6));
    for (let i=-40; i<=40; i+=20) {
      for (let j=-40; j<=40; j+=20) {
        const light = new THREE.PointLight(0xffffcc, 0.8, 30);
        light.position.set(i, 2.9, j);
        scene.add(light);
      }
    }

    // ---------- VARIABLES FPS ----------
    let yaw = 0, pitch = 0;
    let moveX = 0, moveZ = 0;
    let sprint = false;

    // ---------- JOYSTICK ----------
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");
    let joyActive = false, joyCenter = {x:0,y:0}, joyTouchId = null;

    joystick.addEventListener("touchstart", e=>{
      const t = e.changedTouches[0];
      joyTouchId = t.identifier;
      joyActive = true;
      const r = joystick.getBoundingClientRect();
      joyCenter = {x: r.left+r.width/2, y:r.top+r.height/2};
    });

    joystick.addEventListener("touchend", e=>{
      for (const t of e.changedTouches) {
        if (t.identifier === joyTouchId) {
          joyActive = false;
          joyTouchId = null;
          stick.style.left="40px"; stick.style.top="40px";
          moveX=moveZ=0;
        }
      }
    });

    joystick.addEventListener("touchmove", e=>{
      for (const t of e.changedTouches) {
        if (t.identifier === joyTouchId && joyActive) {
          const dx = t.clientX - joyCenter.x;
          const dy = t.clientY - joyCenter.y;
          const maxDist = 50;
          let dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
          const ang = Math.atan2(dy, dx);
          stick.style.left = 40 + dist * Math.cos(ang) - 20 + "px";
          stick.style.top  = 40 + dist * Math.sin(ang) - 20 + "px";

          let nx = dx / maxDist;
          let ny = dy / maxDist;
          const len = Math.sqrt(nx*nx + ny*ny);
          if (len > 0) { nx /= len; ny /= len; }
          moveX = nx;
          moveZ = -ny;
        }
      }
    });

    // ---------- CAMERA TOUCH ----------
    let camTouchId = null;
    let lastX=null,lastY=null;

    document.addEventListener("touchstart", e=>{
      for (const t of e.changedTouches) {
        if (!t.target.closest("#joystick") && camTouchId===null && !t.target.closest("#sprintBtn")) {
          camTouchId = t.identifier;
          lastX = t.clientX;
          lastY = t.clientY;
        }
      }
    });

    document.addEventListener("touchmove", e=>{
      for (const t of e.changedTouches) {
        if (t.identifier === camTouchId) {
          const dx=t.clientX-lastX;
          const dy=t.clientY-lastY;
          lastX=t.clientX; lastY=t.clientY;
          yaw -= dx*0.0025;
          pitch -= dy*0.0025;
          const limit = Math.PI/2.1;
          pitch=Math.max(-limit,Math.min(limit,pitch));
        }
      }
    });

    document.addEventListener("touchend", e=>{
      for (const t of e.changedTouches) {
        if (t.identifier === camTouchId) {
          camTouchId=null; lastX=null; lastY=null;
        }
      }
    });

    // ---------- BOUTON SPRINT ----------
    const sprintBtn = document.getElementById("sprintBtn");
    sprintBtn.addEventListener("touchstart", ()=> sprint = true);
    sprintBtn.addEventListener("touchend", ()=> sprint = false);

    // ---------- MONSTRE ----------
    const monster = new THREE.Mesh(
      new THREE.BoxGeometry(1, 2, 1),
      new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x440000})
    );
    monster.position.set(10,1,10);
    scene.add(monster);

    let monsterActive = false;
    let monsterTimer = 0;
    const monsterSpeed = 1.0;

    function updateMonster(delta) {
      monsterTimer += delta;

      // cycle apparition/disparition
      if (monsterActive && monsterTimer >= 60) {
        monsterActive = false;
        monster.visible = false;
        monsterTimer = 0;
      } else if (!monsterActive && monsterTimer >= 60) {
        monsterActive = true;
        monster.visible = true;
        monsterTimer = 0;
        // respawn loin
        const dist = 20 + Math.random()*30;
        const angle = Math.random()*Math.PI*2;
        monster.position.set(
          camera.position.x + Math.cos(angle)*dist,
          1,
          camera.position.z + Math.sin(angle)*dist
        );
      }

      if (monsterActive) {
        const dir = new THREE.Vector3().subVectors(camera.position, monster.position).normalize();
        monster.position.addScaledVector(dir, monsterSpeed * delta);
        if (monster.position.distanceTo(camera.position) < 1.5) {
          alert("ðŸ’€ Tu es mort dans les Backrooms...");
          window.location.reload();
        }
      }
    }

    // ---------- GAME LOOP ----------
    const clock=new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const delta=clock.getDelta();
      let speed = (sprint ? 3.0 : 1.5) * delta;

      camera.rotation.x=pitch;
      camera.rotation.y=yaw;
      camera.position.y = 1.6;

      const oldPos=camera.position.clone();
      const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
      const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();
      camera.position.addScaledVector(forward, moveZ * speed);
      camera.position.addScaledVector(right, -moveX * speed);

      // collisions murs
      const radius=0.5;
      for(const wall of walls){
        const dx=Math.abs(camera.position.x-wall.position.x);
        const dz=Math.abs(camera.position.z-wall.position.z);
        if(dx < CELL/2+radius && dz < CELL/2+radius){
          camera.position.copy(oldPos);
          break;
        }
      }

      // collisions bords
      const limit=48;
      if(Math.abs(camera.position.x)>limit || Math.abs(camera.position.z)>limit){
        camera.position.copy(oldPos);
      }

      updateMonster(delta);
      renderer.render(scene,camera);
    }
    animate();

    // ---------- RESIZE ----------
    window.addEventListener("resize", ()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  </script>
</body>
</html>






