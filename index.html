<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Backrooms FPS - Joystick fixe</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none;}
    #hud { position:absolute; left:12px; top:12px; color:#fff; font-family:monospace; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:6px; font-size:13px;}
    #joystick {
      position:absolute; left:18px; bottom:28px;
      width:80px; height:80px; border-radius:50%;
      background: rgba(255,255,255,0.06);
      border: 2px solid rgba(255,255,255,0.12);
      touch-action:none;
      -webkit-user-select:none;
    }
    #stick {
      position:absolute;
      width:30px; height:30px; border-radius:50%;
      background: rgba(255,255,255,0.6);
      left:25px; top:25px; /* centered inside 80x80 */
      box-shadow:0 1px 4px rgba(0,0,0,0.6);
      transition: left 0.02s linear, top 0.02s linear;
      touch-action:none;
    }
    /* small helper for desktop testing */
    #instructions { position:absolute; right:12px; top:12px; color:#fff; font-family:monospace; background:rgba(0,0,0,0.25); padding:6px 8px; border-radius:6px; font-size:12px;}
  </style>
</head>
<body>
  <div id="hud">Backrooms â€” mobile FPS (multitouch)</div>
  <div id="instructions">Drag right half to look, left joystick to move</div>
  <div id="joystick"><div id="stick"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  // ---------- CONFIG ----------
  const MAP_HALF = 50;
  const CELL = 10;
  const PLAYER_HEIGHT = 1.6;
  const PLAYER_RADIUS = 0.5;
  const BASE_WALK_SPEED = 0.75; // m/s, already reduced by half
  const CAMERA_SENSITIVITY = 0.0035; // slight increase for responsiveness
  const PITCH_LIMIT = Math.PI * 0.47; // ~85 deg
  const JOY_MAX = 40;     // px radius for joystick
  const JOY_DEADZONE = 0.15; // normalized deadzone (0..1)

  // ---------- THREE INIT ----------
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0xe6e6d8, 0.0035);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // camera & FPS hierarchy
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.rotation.order = 'YXZ';
  const yawObject = new THREE.Object3D();
  const pitchObject = new THREE.Object3D();
  yawObject.add(pitchObject);
  pitchObject.add(camera);
  yawObject.position.set(0, PLAYER_HEIGHT, 0);
  scene.add(yawObject);

  // ---------- TEXTURES ----------
  const loader = new THREE.TextureLoader();
  const texFloor = loader.load("https://ambientcg.com/get?file=Carpet006_1K_Color.jpg");
  texFloor.wrapS = texFloor.wrapT = THREE.RepeatWrapping; texFloor.repeat.set(40,40);
  const texWall = loader.load("https://ambientcg.com/get?file=Wallpaper001_1K_Color.jpg");
  texWall.wrapS = texWall.wrapT = THREE.RepeatWrapping; texWall.repeat.set(4,2);
  const texCeil = loader.load("https://ambientcg.com/get?file=CeilingTile001_1K_Color.jpg");
  texCeil.wrapS = texCeil.wrapT = THREE.RepeatWrapping; texCeil.repeat.set(40,40);

  // floor & ceiling
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF*2, MAP_HALF*2), new THREE.MeshStandardMaterial({map:texFloor}));
  floor.rotation.x = -Math.PI/2; scene.add(floor);
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF*2, MAP_HALF*2), new THREE.MeshStandardMaterial({map:texCeil}));
  ceiling.position.y = 3; ceiling.rotation.x = Math.PI/2; scene.add(ceiling);

  // ---------- WALLS ----------
  const walls = [];
  const wallGeo = new THREE.BoxGeometry(CELL,3,CELL);
  const wallMat = new THREE.MeshStandardMaterial({map:texWall});
  for (let x = -MAP_HALF + CELL/2; x <= MAP_HALF - CELL/2; x += CELL) {
    for (let z = -MAP_HALF + CELL/2; z <= MAP_HALF - CELL/2; z += CELL) {
      const isBorder = Math.abs(x) > MAP_HALF - CELL*1.5 || Math.abs(z) > MAP_HALF - CELL*1.5;
      if (isBorder || Math.random() > 0.78) {
        const w = new THREE.Mesh(wallGeo, wallMat);
        w.position.set(x, 1.5, z);
        scene.add(w);
        walls.push(w);
      }
    }
  }

  // ---------- LIGHTS ----------
  scene.add(new THREE.AmbientLight(0xffffe0, 0.45));
  const neonLights = [];
  for (let i=-40;i<=40;i+=20){
    for (let j=-40;j<=40;j+=20){
      const l = new THREE.PointLight(0xffffcc, 0.8, 35, 2);
      l.position.set(i, 2.8, j);
      scene.add(l);
      neonLights.push(l);
    }
  }
  function updateNeonFlicker(t){
    neonLights.forEach((l,idx)=>{
      const base = 0.8 + Math.sin(t*3.2 + idx) * 0.06;
      const spike = (Math.random() > 0.996) ? 1.6 : 1.0;
      l.intensity = base * spike;
    });
  }

  // ---------- AUDIO ----------
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const sound = new THREE.Audio(listener);
  const audioLoader = new THREE.AudioLoader();
  audioLoader.load("https://cdn.pixabay.com/download/audio/2021/09/13/audio_bf19c9c6d7.mp3?filename=neon-light-buzz-6407.mp3",
    (buf)=>{ sound.setBuffer(buf); sound.setLoop(true); sound.setVolume(0.22); sound.play(); },
    undefined, ()=>{ /* ignore */ });

  // ---------- INPUT STATE ----------
  let yaw = 0, pitch = 0;
  let moveX = 0, moveZ = 0; // normalized movement direction: X=strafe, Z=forward
  let joyTouchId = null, joyCenter = {x:0,y:0}, joyActive=false;

  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');

  // JOYSTICK: multi-touch friendly, normalization to constant speed, deadzone
  joystick.addEventListener('touchstart', (ev)=> {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (joyTouchId === null) {
        joyTouchId = t.identifier;
        joyActive = true;
        const r = joystick.getBoundingClientRect();
        joyCenter.x = r.left + r.width/2;
        joyCenter.y = r.top + r.height/2;
      }
    }
  }, {passive:false});

  joystick.addEventListener('touchmove', (ev)=> {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (t.identifier === joyTouchId && joyActive) {
        const dx = t.clientX - joyCenter.x;
        const dy = t.clientY - joyCenter.y;
        const maxDist = JOY_MAX;
        let dist = Math.hypot(dx, dy);
        if (dist > maxDist) dist = maxDist;
        const ang = Math.atan2(dy, dx);
        // visual stick
        stick.style.left = `${( (80-30)/2 ) + dist * Math.cos(ang)}px`;
        stick.style.top  = `${( (80-30)/2 ) + dist * Math.sin(ang)}px`;

        // normalized coordinates [-1..1]
        let nx = dx / maxDist;
        let ny = dy / maxDist;
        let len = Math.hypot(nx, ny);

        // deadzone: small nudge does nothing
        if (len < JOY_DEADZONE) {
          moveX = 0; moveZ = 0;
        } else {
          // normalize direction to constant magnitude (1.0)
          nx /= len; ny /= len;
          // map axes: positive moveZ = forward, positive moveX = right
          moveX = nx;
          moveZ = -ny;
        }
      }
    }
  }, {passive:false});

  joystick.addEventListener('touchend', (ev)=> {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (t.identifier === joyTouchId) {
        joyTouchId = null; joyActive = false;
        moveX = 0; moveZ = 0;
        // recenter visual stick
        stick.style.left = `${(80-30)/2}px`;
        stick.style.top  = `${(80-30)/2}px`;
      }
    }
  }, {passive:false});

  // CAMERA TOUCH (separate finger)
  let camTouchId = null, lastCamX = 0, lastCamY = 0;
  document.addEventListener('touchstart', (ev) => {
    for (const t of ev.changedTouches) {
      // ignore touches that started on the joystick DOM
      if (t.target && t.target.closest && t.target.closest('#joystick')) continue;
      if (camTouchId === null) {
        camTouchId = t.identifier;
        lastCamX = t.clientX; lastCamY = t.clientY;
      }
    }
  }, {passive:true});

  document.addEventListener('touchmove', (ev) => {
    for (const t of ev.changedTouches) {
      if (t.identifier === camTouchId) {
        const dx = t.clientX - lastCamX;
        const dy = t.clientY - lastCamY;
        lastCamX = t.clientX; lastCamY = t.clientY;
        yaw -= dx * CAMERA_SENSITIVITY;
        pitch -= dy * CAMERA_SENSITIVITY;
        pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      }
    }
  }, {passive:true});

  document.addEventListener('touchend', (ev) => {
    for (const t of ev.changedTouches) {
      if (t.identifier === camTouchId) { camTouchId = null; lastCamX = lastCamY = 0; }
    }
  }, {passive:true});

  // mouse & keyboard support for desktop testing
  let mouseDown=false, lastMouseX=0, lastMouseY=0;
  document.addEventListener('mousedown', (e)=>{ mouseDown=true; lastMouseX=e.clientX; lastMouseY=e.clientY; });
  document.addEventListener('mousemove', (e)=>{ if(!mouseDown) return; const dx=e.clientX-lastMouseX, dy=e.clientY-lastMouseY; lastMouseX=e.clientX; lastMouseY=e.clientY; yaw -= dx*CAMERA_SENSITIVITY*1.2; pitch -= dy*CAMERA_SENSITIVITY*1.2; pitch=Math.max(-PITCH_LIMIT,Math.min(PITCH_LIMIT,pitch)); });
  document.addEventListener('mouseup', ()=> mouseDown=false);

  const keys = {};
  window.addEventListener('keydown', (e)=> keys[e.code]=true);
  window.addEventListener('keyup', (e)=> keys[e.code]=false);

  // ---------- GAME LOOP ----------
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.elapsedTime;
    updateNeonFlicker(t);

    // apply rotations to objects
    pitchObject.rotation.x = pitch;
    yawObject.rotation.y = yaw;

    // head bob - very subtle
    const moving = Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01 || keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];
    const bob = moving ? Math.sin(t * 8) * 0.01 : 0;
    yawObject.position.y = PLAYER_HEIGHT + Math.max(0, bob);

    // keyboard fallback mapping (desktop)
    let kbForward = 0, kbStrafe = 0;
    if (keys['KeyW'] || keys['KeyZ']) kbForward += 1;
    if (keys['KeyS']) kbForward -= 1;
    if (keys['KeyD']) kbStrafe += 1;
    if (keys['KeyA'] || keys['KeyQ']) kbStrafe -= 1;

    // final movement direction: joystick prioritized
    const finalForward = Math.abs(moveZ) > 0.01 ? moveZ : kbForward;
    const finalStrafe  = Math.abs(moveX) > 0.01 ? moveX : kbStrafe;

    // movement in world space (based on yawObject orientation)
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(yawObject.quaternion).setY(0).normalize();
    const right   = new THREE.Vector3(1,0,0).applyQuaternion(yawObject.quaternion).setY(0).normalize();

    // constant speed (independent from stick displacement)
    const moveSpeed = BASE_WALK_SPEED * dt;
    const deltaPos = forward.clone().multiplyScalar(finalForward * moveSpeed)
                       .add(right.clone().multiplyScalar(finalStrafe * moveSpeed));

    const oldPos = yawObject.position.clone();
    yawObject.position.x += deltaPos.x;
    yawObject.position.z += deltaPos.z;

    // clamp to map bounding box
    const bound = MAP_HALF - PLAYER_RADIUS - 0.01;
    if (yawObject.position.x < -bound || yawObject.position.x > bound ||
        yawObject.position.z < -bound || yawObject.position.z > bound) {
      yawObject.position.copy(oldPos);
    } else {
      // simple AABB collision vs walls
      for (const w of walls) {
        const dx = Math.abs(yawObject.position.x - w.position.x);
        const dz = Math.abs(yawObject.position.z - w.position.z);
        if (dx < (CELL/2 + PLAYER_RADIUS) && dz < (CELL/2 + PLAYER_RADIUS)) {
          yawObject.position.copy(oldPos);
          break;
        }
      }
    }

    renderer.render(scene, camera);
  }
  animate();

  // ---------- RESIZE ----------
  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  </script>
</body>
</html>


