<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Backrooms Horror - FPS</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; touch-action:none; -webkit-touch-callout:none; -webkit-user-select:none; -ms-user-select:none; user-select:none; }
    #hud { position: absolute; left: 12px; top: 12px; color: white; font-family: monospace; background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:6px; font-size:13px; }
    #joystick { position:absolute; left:18px; bottom:28px; width:88px; height:88px; border-radius:50%; background: rgba(255,255,255,0.06); border: 2px solid rgba(255,255,255,0.12); touch-action:none; }
    #stick { position:absolute; left:29px; top:29px; width:30px; height:30px; border-radius:50%; background: rgba(255,255,255,0.6); box-shadow:0 1px 4px rgba(0,0,0,0.6); }
  </style>
</head>
<body>
  <div id="hud">Backrooms — mobile FPS (multitouch)</div>
  <div id="joystick"><div id="stick"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  // ---------- CONFIG ----------
  const MAP_HALF_SIZE = 50;   // map extends -50..+50 (so full width = 100)
  const CELL = 10;
  const PLAYER_HEIGHT = 1.6;
  const PLAYER_RADIUS = 0.5;
  const BASE_WALK_SPEED = 0.75; // reduced (m/s) * delta used later
  const CAMERA_SENSITIVITY = 0.0035; // slightly increased for snappier feel
  const PITCH_LIMIT = Math.PI * 0.47; // ~85 degrees

  // ---------- THREE INIT ----------
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0xe6e6d8, 0.0035);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.rotation.order = 'YXZ'; // important for FPS style yaw (Y) then pitch (X)
  camera.position.set(0, PLAYER_HEIGHT, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = false;
  document.body.appendChild(renderer.domElement);

  // ---------- TEXTURES ----------
  const loader = new THREE.TextureLoader();
  const texFloor = loader.load("https://ambientcg.com/get?file=Carpet006_1K_Color.jpg");
  texFloor.wrapS = texFloor.wrapT = THREE.RepeatWrapping;
  texFloor.repeat.set(40,40);

  const texWall = loader.load("https://ambientcg.com/get?file=Wallpaper001_1K_Color.jpg");
  texWall.wrapS = texWall.wrapT = THREE.RepeatWrapping;
  texWall.repeat.set(4,2);

  const texCeil = loader.load("https://ambientcg.com/get?file=CeilingTile001_1K_Color.jpg");
  texCeil.wrapS = texCeil.wrapT = THREE.RepeatWrapping;
  texCeil.repeat.set(40,40);

  // ---------- FLOOR / CEILING ----------
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF_SIZE*2, MAP_HALF_SIZE*2), new THREE.MeshStandardMaterial({ map: texFloor }));
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(MAP_HALF_SIZE*2, MAP_HALF_SIZE*2), new THREE.MeshStandardMaterial({ map: texCeil }));
  ceiling.position.y = 3;
  ceiling.rotation.x = Math.PI/2;
  scene.add(ceiling);

  // ---------- WALLS (procedural scatter) ----------
  const walls = [];
  const wallGeo = new THREE.BoxGeometry(CELL, 3, CELL);
  const wallMat = new THREE.MeshStandardMaterial({ map: texWall });

  for (let x = -MAP_HALF_SIZE + CELL/2; x <= MAP_HALF_SIZE - CELL/2; x += CELL) {
    for (let z = -MAP_HALF_SIZE + CELL/2; z <= MAP_HALF_SIZE - CELL/2; z += CELL) {
      // place border walls (outer ring) and some random interior walls
      const isBorder = Math.abs(x) > MAP_HALF_SIZE - CELL*1.5 || Math.abs(z) > MAP_HALF_SIZE - CELL*1.5;
      if (isBorder || Math.random() > 0.78) {
        const w = new THREE.Mesh(wallGeo, wallMat);
        w.position.set(x, 1.5, z);
        scene.add(w);
        walls.push(w);
      }
    }
  }

  // ---------- LIGHTING (néons ambiants + subtle flicker) ----------
  scene.add(new THREE.AmbientLight(0xffffe0, 0.45));
  const neonLights = [];
  for (let i = -40; i <= 40; i += 20) {
    for (let j = -40; j <= 40; j += 20) {
      const l = new THREE.PointLight(0xffffcc, 0.8, 35, 2);
      l.position.set(i, 2.8, j);
      scene.add(l);
      neonLights.push(l);
    }
  }

  // add subtle flicker groups (for horror feel)
  function updateNeonFlicker(t) {
    neonLights.forEach((l, idx) => {
      // per-light slight offset, occasional stronger flicker
      const base = 0.8 + Math.sin(t * 3.2 + idx) * 0.08;
      const randomSpike = (Math.sin(t * (0.8 + (idx%3)*0.15)) > 0.995) ? 1.6 : 1.0;
      l.intensity = base * randomSpike;
    });
  }

  // ---------- AUDIO (neon hum) ----------
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const sound = new THREE.Audio(listener);
  const audioLoader = new THREE.AudioLoader();
  audioLoader.load("https://cdn.pixabay.com/download/audio/2021/09/13/audio_bf19c9c6d7.mp3?filename=neon-light-buzz-6407.mp3",
    (buf) => { sound.setBuffer(buf); sound.setLoop(true); sound.setVolume(0.22); sound.play(); },
    undefined,
    ()=>{} // ignore errors silently
  );

  // ---------- HUD / UI already present ----------
  // joystick DOM
  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');

  // ---------- INPUT (multitouch) ----------
  // We'll track two touch ids: joyTouchId (for joystick), camTouchId (for camera)
  let joyTouchId = null, camTouchId = null;
  let joyCenter = { x: 0, y: 0 }, joyActive = false;
  let moveX = 0, moveZ = 0;
  let lastCamX = 0, lastCamY = 0;
  let yaw = 0, pitch = 0;

  // helpers to clamp camera within bounding box
  function clampPositionToBounds(pos) {
    const margin = PLAYER_RADIUS + 0.001;
    pos.x = Math.max(-MAP_HALF_SIZE + margin, Math.min(MAP_HALF_SIZE - margin, pos.x));
    pos.z = Math.max(-MAP_HALF_SIZE + margin, Math.min(MAP_HALF_SIZE - margin, pos.z));
  }

  // joystick touch handlers
  joystick.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (joyTouchId === null) {
        joyTouchId = t.identifier;
        joyActive = true;
        const r = joystick.getBoundingClientRect();
        joyCenter.x = r.left + r.width/2;
        joyCenter.y = r.top + r.height/2;
      }
    }
  }, { passive: false });

  joystick.addEventListener('touchmove', (ev) => {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (t.identifier === joyTouchId && joyActive) {
        const dx = t.clientX - joyCenter.x;
        const dy = t.clientY - joyCenter.y;
        const maxDist = 40;
        const dist = Math.min(Math.hypot(dx, dy), maxDist);
        const ang = Math.atan2(dy, dx);
        stick.style.left = `${35 + dist * Math.cos(ang) - 15}px`;
        stick.style.top  = `${35 + dist * Math.sin(ang) - 15}px`;
        // Normalize to [-1,1] with deadzone
        const nx = dx / maxDist;
        const nz = dy / maxDist;
        const dead = 0.06;
        moveX = Math.abs(nx) < dead ? 0 : Math.max(-1, Math.min(1, nx));
        moveZ = Math.abs(nz) < dead ? 0 : Math.max(-1, Math.min(1, nz));
      }
    }
  }, { passive: false });

  joystick.addEventListener('touchend', (ev) => {
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (t.identifier === joyTouchId) {
        joyTouchId = null; joyActive = false; moveX = 0; moveZ = 0;
        stick.style.left = '29px'; stick.style.top = '29px'; // visually recentre (fits 88px)
      }
    }
  }, { passive: false });

  // camera touch handlers (separate touch)
  document.addEventListener('touchstart', (ev) => {
    for (const t of ev.changedTouches) {
      // ignore touches that started on joystick area (we already track those)
      if (t.target && t.target.closest && t.target.closest('#joystick')) continue;
      if (camTouchId === null) {
        camTouchId = t.identifier;
        lastCamX = t.clientX; lastCamY = t.clientY;
      }
    }
  }, { passive: true });

  document.addEventListener('touchmove', (ev) => {
    for (const t of ev.changedTouches) {
      if (t.identifier === camTouchId) {
        const dx = t.clientX - lastCamX;
        const dy = t.clientY - lastCamY;
        lastCamX = t.clientX; lastCamY = t.clientY;
        yaw -= dx * CAMERA_SENSITIVITY;
        pitch -= dy * CAMERA_SENSITIVITY;
        // clamp pitch to avoid flip/looping
        pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      }
    }
  }, { passive: true });

  document.addEventListener('touchend', (ev) => {
    for (const t of ev.changedTouches) {
      if (t.identifier === camTouchId) { camTouchId = null; lastCamX = lastCamY = null; }
    }
  }, { passive: true });

  // also support mouse for desktop testing (drag to turn, WASD)
  let mouseDown = false;
  let lastMouseX = 0, lastMouseY = 0;
  document.addEventListener('mousedown', (e) => { mouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
  document.addEventListener('mousemove', (e) => {
    if (!mouseDown) return;
    const dx = e.clientX - lastMouseX, dy = e.clientY - lastMouseY;
    lastMouseX = e.clientX; lastMouseY = e.clientY;
    yaw -= dx * (CAMERA_SENSITIVITY*1.2);
    pitch -= dy * (CAMERA_SENSITIVITY*1.2);
    pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
  });
  document.addEventListener('mouseup', ()=> mouseDown = false);

  // keyboard fallback (for desktop)
  const keys = {};
  window.addEventListener('keydown', (e)=> keys[e.code] = true);
  window.addEventListener('keyup', (e)=> keys[e.code] = false);

  // ---------- HEAD BOB (subtle) ----------
  let headBob = 0;
  function applyHeadBob(dt) {
    const moving = Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01 || keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];
    if (moving) headBob += dt * 8;
    else headBob = Math.max(0, headBob - dt * 6);
    const bobAmount = moving ? Math.sin(headBob) * 0.02 : 0;
    return bobAmount;
  }

  // ---------- GAME LOOP ----------
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.elapsedTime;

    // neon flicker
    updateNeonFlicker(t);

    // CAMERA rotations (apply yaw/pitch)
    camera.rotation.x = pitch;
    camera.rotation.y = yaw;
    camera.rotation.z = 0; // no roll

    // ensure camera Y fixed (no go into floor)
    camera.position.y = PLAYER_HEIGHT + Math.max(0, applyHeadBob(dt)); // slight bob over time when moving

    // MOVEMENT
    // keyboard support: map WASD/ZQSD to moveX/moveZ on desktop
    let kx = 0, kz = 0;
    if (keys['KeyW'] || keys['KeyZ']) kz -= 1;
    if (keys['KeyS']) kz += 1;
    if (keys['KeyA'] || keys['KeyQ']) kx -= 1;
    if (keys['KeyD']) kx += 1;
    // combine keyboard and joystick (joystick prioritized if used)
    const finalMoveX = Math.abs(moveX) > 0.01 ? moveX : (kx === 0 ? 0 : (kx));
    const finalMoveZ = Math.abs(moveZ) > 0.01 ? moveZ : (kz === 0 ? 0 : (kz));

    // compute move vector in world space
    const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    // consistent speed in all directions (reduced half) — BASE_WALK_SPEED is m/s, multiply by dt
    const moveSpeed = BASE_WALK_SPEED * dt * 2.0; // factor 2 keeps feel similar to earlier scaling
    const dx = forward.clone().multiplyScalar(-finalMoveZ * moveSpeed).add(right.clone().multiplyScalar(-finalMoveX * moveSpeed));

    const oldPos = camera.position.clone();
    camera.position.x += dx.x;
    camera.position.z += dx.z;

    // clamp to bounding box (map edges collision)
    clampPositionToBounds(camera.position);

    // wall collisions: simple AABB check against each wall (cheap but okay for this demo)
    for (const w of walls) {
      const distX = Math.abs(camera.position.x - w.position.x);
      const distZ = Math.abs(camera.position.z - w.position.z);
      const overlapX = distX < (CELL/2 + PLAYER_RADIUS);
      const overlapZ = distZ < (CELL/2 + PLAYER_RADIUS);
      if (overlapX && overlapZ) {
        // collision -> revert to old position
        camera.position.copy(oldPos);
        break;
      }
    }

    renderer.render(scene, camera);
  }
  animate();

  // ---------- RESIZE ----------
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  </script>
</body>
</html>












