<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Backrooms FPS + Shrek Monster</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none}
    #joystick{position:absolute;left:20px;bottom:30px;width:120px;height:120px;border-radius:50%;background:rgba(255,255,255,0.06);border:2px solid rgba(255,255,255,0.12);touch-action:none}
    #stick{position:absolute;width:40px;height:40px;border-radius:50%;background:rgba(255,255,255,0.6);left:40px;top:40px;box-shadow:0 1px 6px rgba(0,0,0,0.6);transition:left .02s linear,top .02s linear}
    #sprintBtn{position:absolute;right:25px;bottom:40px;width:90px;height:90px;border-radius:50%;background:rgba(255,255,255,0.15);border:2px solid rgba(255,255,255,0.25);color:#fff;font-size:18px;text-align:center;line-height:90px;user-select:none}
    #gameOver{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);color:#fff;font-family:monospace;font-size:30px;z-index:999;display:none;flex-direction:column}
    #gameOver button{margin-top:16px;padding:10px 18px;font-size:16px}
  </style>
</head>
<body>
  <div id="joystick"><div id="stick"></div></div>
  <div id="sprintBtn">Sprint</div>
  <div id="gameOver"><div>💀 Tu es mort...</div><button id="restartBtn">Recommencer</button></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

  <script>
  // (tout ton code d’avant jusqu’à la partie “MONSTER IA”) …

  // ---------------- MONSTER remplacé par Shrek avec animation ----------------
  let monster; 
  let mixer; 
  let shrekLoaded = false;

  const gltfLoader = new THREE.GLTFLoader();
  // Remplace ce lien par le lien vers ton fichier .glb/ .gltf de Shrek riggé
  gltfLoader.load("shrek_rig.glb", (gltf) => {
    monster = gltf.scene;
    monster.scale.set(1.5, 1.5, 1.5); // ajuster la taille
    monster.visible = false;
    scene.add(monster);

    mixer = new THREE.AnimationMixer(monster);
    if (gltf.animations && gltf.animations.length > 0) {
      const walkAction = mixer.clipAction(gltf.animations[0]);
      walkAction.play();
    }
    shrekLoaded = true;
  }, undefined, (error) => {
    console.error("Erreur chargement Shrek:", error);
  });

  // Adaptation de spawn / updateMonster

  function spawnMonsterBehindPlayer() {
    if (!monster) return;
    const playerPos = yawObject.position.clone();
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(yawObject.quaternion).setY(0).normalize();
    const target = playerPos.clone().sub(forward.clone().multiplyScalar(MONSTER_SPAWN_BEHIND_DIST));
    const bound = MAP_HALF - 2.0;
    if (Math.abs(target.x) <= bound && Math.abs(target.z) <= bound && !collidesWithWalls(target.x, target.z)) {
      monster.position.set(target.x, 1.0, target.z);
    } else {
      // fallback random spawn (ton code déjà existant)
      for (let attempt=0; attempt<40; attempt++) {
        const angle = Math.random() * Math.PI*2;
        const dist = MONSTER_MIN_SPAWN_DIST + Math.random() * (MONSTER_MAX_SPAWN_DIST - MONSTER_MIN_SPAWN_DIST);
        const x = playerPos.x + Math.cos(angle)*dist;
        const z = playerPos.z + Math.sin(angle)*dist;
        if (Math.abs(x) > MAP_HALF-2 || Math.abs(z) > MAP_HALF-2) continue;
        if (!collidesWithWalls(x, z)) {
          monster.position.set(x, 1.0, z);
          return;
        }
      }
      monster.position.set(target.x, 1.0, target.z);
    }
  }

  function updateMonster(dt) {
    if (!shrekLoaded) return;  // ne fait rien tant que Shrek pas chargé
    // ton code existant de gestion ON/OFF …
    if (monsterState === 'on') {
      // poursuivre joueur
      const target = new THREE.Vector3(yawObject.position.x, monster.position.y, yawObject.position.z);
      const dir = new THREE.Vector3().subVectors(target, monster.position);
      dir.y = 0;
      const distToPlayer = dir.length();
      if (distToPlayer > 0.001) dir.normalize();

      const step = Math.min(MONSTER_SPEED * dt, distToPlayer);
      let nextPos = monster.position.clone().add(dir.clone().multiplyScalar(step));

      let collision = false;
      if (collidesWithWalls(nextPos.x, nextPos.z)) collision = true;
      const bound = MAP_HALF - 1.0;
      if (nextPos.x < -bound || nextPos.x > bound || nextPos.z < -bound || nextPos.z > bound) collision = true;

      if (collision) {
        const perp = new THREE.Vector3(-dir.z, 0, dir.x);
        let moved = false;
        for (let s = 0; s < 2; s++) {
          const sign = s === 0 ? 1 : -1;
          const alt = monster.position.clone()
            .add(dir.clone().multiplyScalar(step * 0.9))
            .add(perp.clone().multiplyScalar(sign * step * 0.9));
          if (!collidesWithWalls(alt.x, alt.z) 
              && Math.abs(alt.x) <= bound && Math.abs(alt.z) <= bound) {
            nextPos = alt;
            moved = true;
            break;
          }
        }
        if (!moved) {
          nextPos = monster.position.clone();
        }
      }

      monster.position.copy(nextPos);

      const lookDir = new THREE.Vector3(yawObject.position.x - monster.position.x, 0, yawObject.position.z - monster.position.z);
      if (lookDir.lengthSq() > 0.001) {
        monster.rotation.y = Math.atan2(lookDir.x, lookDir.z);
      }

      const bob = Math.sin(performance.now() * 0.002) * 0.12;
      monster.position.y = 1.0 + bob;

      if (distToPlayer < MONSTER_GROWL_DIST) {
        if (!monsterGrowlPlaying && growl.isBuffer) {
          growl.play();
          monsterGrowlPlaying = true;
        }
      } else {
        if (monsterGrowlPlaying && growl.isPlaying) {
          growl.stop();
          monsterGrowlPlaying = false;
        }
      }

      if (distToPlayer < 1.5) {
        triggerGameOver();
      }
    }

    // Animation update
    if (mixer) mixer.update(dt);
  }

  // dans animate()
  animate = () => {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    // … avant render, appelle updateMonster(dt)
    updateMonster(dt);
    renderer.render(scene, camera);
  };

  // (le reste de ton script identique) …
  </script>
</body>
</html>








